
using System;
using System.IO;
using System.Threading;
using System.Text;
using System.Reflection;
using System.Collections;

namespace wb
{
  public class wb
  {
    public static int invokeFunc(String funcName, params Object[] args)
    {
      MethodInfo method = typeof(wb).GetMethod(funcName);
      return (int) method.Invoke(null, args);//first parameter is null for all static methods.
    }

    /* This file was generated by scm2cs from source file "handle.scm" */
    /*  "handle.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000, 2007, 2010 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */

    /*  routines in this file return success codes */




    public static bool cleverCacheEnable_P = (true);
    

    public static bool hanError_P(wb.Han han,String caller)
    {
      if (!(a2b(han)))
        {
          Console.Error.Write(">>>>ERROR<<<< "+(caller)+": called with NULL handle.\n");
          return (true);
        }
      else if (!(a2b(han_Seg(han))))
        {
          Console.Error.Write(">>>>ERROR<<<< "+(caller)+": called with handle having NULL segment.\n");
          return (true);
        }
      else return false;
    }
    

    public static bool keyError_P(byte []keyStr,int kLen,int xcpt,String caller)
    {
      if ((xcpt)==(kLen))
        return false;
      else if (!(0<=(kLen)
              && (kLen)<=0xff))
        {
          Console.Error.Write(">>>>ERROR<<<< "+(caller)+": key-length, "+(kLen)+", was out of range 0 <= 255.\n");
          return (true);
        }
      else if (0 < (kLen)
          && 0xff==((keyStr[0] & 0xFF)))
        {
          Console.Error.Write(">>>>ERROR<<<< "+(caller)+": first byte of key must not be 255.\n");
          return (true);
        }
      else return false;
    }
    

    public static int btGet(wb.Han han,byte []keyStr,int kLen,byte []ansStr)
    {
      int []pkt = new int[pktSize];
      Ent ent = null;
      if (keyError_P(keyStr, kLen, 0, "btGet"))
        return keyerr;
      else if (hanError_P(han, "btGet"))
        return argerr;
      else {
        ent = chainFindEnt(han, accread, keyStr, kLen, pkt);
        if (!(a2b(ent)))
          {
            getFct = 1+(getFct);
            return unkerr;
          }
        else if ((pkt_MatchType(pkt))!=(match))
          {
            getCt = 1+(getCt);
            releaseEnt(ent, accread);
            return notpres;
          }
        else {
          int alen = getThisVal(ent_Blk(ent), pkt_MatchPos(pkt), ansStr);
          getCt = 1+(getCt);
          releaseEnt(ent, accread);
          return alen;
        }
      }
    }
    

    public static int btNext(wb.Han han,byte []keyStr,int kLen,byte []ansStr)
    {
      int []pkt = new int[pktSize];
      Ent ent = null;
      if (keyError_P(keyStr, kLen,  -2, "btNext"))
        return keyerr;
      else if (hanError_P(han, "btNext"))
        return argerr;
      else {
        ent = chainFindEnt(han, accread, keyStr, kLen, pkt);
        if (!(a2b(ent)))
          {
            nextFct = 1+(nextFct);
            return unkerr;
          }
        else {
          nextCt = 1+(nextCt);
          {
            int res = chainNext(ent, keyStr, kLen, ansStr, pkt);
            if (cleverCacheEnable_P)
              han_SetLast(han, pkt_BlkToCache(pkt));
            return res;
          }
        }
      }
    }
    

    public static int btPrev(wb.Han han,byte []keyStr,int kLen,byte []ansStr)
    {
      int []pkt = new int[pktSize];
      Ent ent = null;
      if (keyError_P(keyStr, kLen,  -1, "btPrev"))
        return keyerr;
      else if (hanError_P(han, "btPrev"))
        return argerr;
      else {
        ent = chainFindPrevEnt(han, accread, keyStr, kLen, pkt);
        if (a2b(ent))
          {
            ent = prev_PrevKEnt(ent, keyStr, kLen, leaf, pkt);
          }
        else ;
        if (!(a2b(ent)))
          {
            prevFct = 1+(prevFct);
            return unkerr;
          }
        else {
          prevCt = 1+(prevCt);
          if (0==(pkt_MatchPos(pkt)))
            {
              releaseEnt(ent, accread);
              return notpres;
            }
          else {
            int kLen2 = reconThisKey(ent_Blk(ent), pkt_MatchPos(pkt), ansStr, 0, 0x100);
            han_SetLast(han, ent_Id(ent));
            releaseEnt(ent, accread);
            return kLen2;
          }
        }
      }
    }
    

    public static int btRem(wb.Han han,byte []keyStr,int kLen,byte []ansStr)
    {
      int []pkt = new int[pktSize];
      Ent ent = null;
      if (keyError_P(keyStr, kLen, 0, "btRem"))
        return keyerr;
      else if (hanError_P(han, "btRem"))
        return argerr;
      else {
        ent = chainFindEnt(han, accwrite, keyStr, kLen, pkt);
        if (!(a2b(ent)))
          {
            remFct = 1+(remFct);
            return unkerr;
          }
        else {
          remCt = 1+(remCt);
          {
            int ans = del_ChainRem(ent, keyStr, kLen, ansStr, pkt, han_Wcb(han));
            releaseEnt(ent, accwrite);
            return ans;
          }
        }
      }
    }
    
    /*  To make possible bounded-time operation, @0 will purge at most */
    /*  BLK-LIMIT blocks at a time; passing BLK-LIMIT of -1 imposes no */
    /*  limit. */


    public static int btRemRange(wb.Han han,byte []keyStr,int kLen,byte []key2Str,int k2Len)
    {
      int []respkt = new int[pktSize];
      pkt_SetSkeyCount(respkt, 0);
      return btScan(han, remScan, keyStr, kLen, key2Str, k2Len, null, null, respkt,  -1);
    }
    

    public static int btPut(wb.Han han,byte []keyStr,int kLen,byte []valStr,int vLen)
    {
      Ent ent = null;
      int []pkt = new int[pktSize];
      if (keyError_P(keyStr, kLen, 0, "btPut"))
        return keyerr;
      else if (hanError_P(han, "btPut"))
        return argerr;
      else if (!(0<=(vLen)
              && (vLen)<=0xff))
        return argerr;
      else {
        ent = chainFindEnt(han, accwrite, keyStr, kLen, pkt);
        if (!(a2b(ent)))
          return unkerr;
        else {
          bool res_P = chainPut(ent, keyStr, kLen, valStr, vLen, pkt, null, han_Wcb(han));
          if (res_P)
            {
              if (cleverCacheEnable_P)
                han_SetLast(han, pkt_BlkToCache(pkt));
              putCt = 1+(putCt);
              return success;
            }
          else {
            putFct = 1+(putFct);
            return unkerr;
          }
        }
      }
    }
    

    public static int btWrite(wb.Han han,byte []keyStr,int kLen,byte []valStr,int vLen)
    {
      Ent ent = null;
      int []pkt = new int[pktSize];
      if (keyError_P(keyStr, kLen, 0, "btWrite"))
        return keyerr;
      else if (hanError_P(han, "btWrite"))
        return argerr;
      else if (!(0<=(vLen)
              && (vLen)<=0xff))
        return argerr;
      else {
        ent = chainFindEnt(han, accwrite, keyStr, kLen, pkt);
        if (!(a2b(ent)))
          return unkerr;
        else if ((pkt_MatchType(pkt))==(match))
          {
            releaseEnt(ent, accwrite);
            return notpres;
          }
        else {
          bool res_P = chainPut(ent, keyStr, kLen, valStr, vLen, pkt, null, han_Wcb(han));
          if (res_P)
            {
              if (cleverCacheEnable_P)
                han_SetLast(han, pkt_BlkToCache(pkt));
              putCt = 1+(putCt);
              return success;
            }
          else {
            putFct = 1+(putFct);
            return unkerr;
          }
        }
      }
    }
    
    /* This file was generated by scm2cs from source file "segs.scm" */
    /*  "segs.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000, 2007, 2010 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */

    /*  routines in this file return success codes */




    public static int initWb(int maxNumEntsCnt,int maxNumBuks,int maxBlkSize)
    {
      if (!(0xc<=(maxNumEntsCnt)))
        {
          Console.Error.Write(">>>>ERROR<<<< "+("initWb")+": "+("maxNumEntsCnt")+" ("+(maxNumEntsCnt)+") must be "+0xc
   +" or greater.\n");
          return argerr;
        }
      else if (!(0xc<=(maxNumBuks)))
        {
          Console.Error.Write(">>>>ERROR<<<< "+("initWb")+": "+("maxNumBuks")+" ("+(maxNumBuks)+") must be "+0xc
   +" or greater.\n");
          return argerr;
        }
      else if (!(0x80<=(maxBlkSize)))
        {
          Console.Error.Write(">>>>ERROR<<<< "+("initWb")+": "+("maxBlkSize")+" ("+(maxBlkSize)+") must be "+0x80
   +" or greater.\n");
          return argerr;
        }
      else 
      lck(segChainLck);
      if (tryLck_P(segChainLck))
        {
          Console.Error.Write(">>>>ERROR<<<< "+("initWb")+": lck (mutex) is not self-blocking!\n");
          return strangerr;
        }
      else if (!(a2b(lckTab)))
        {
          blkio_Init();
          clearStats();
          segCntr = 4;
          numBuks = maxNumBuks;
          blkSize = maxBlkSize;
          freeBukCntr = 0;
          flushEntCntr = 0;
          bukTab = new Ent[numBuks];
          lckTab = new Lck[numBuks];
          entTab = new Ent[entTabInc];
          {
            int i = numBuks;
            while (!(0==(i))) {
              lckTab[(i)-1] = makeLck((i)-1);
              {
                i = (i)-1;
              }
            }
          }
          lck(freeEntLck);
          {
            int i = maxNumEntsCnt;
            Ent bent = null;
            while (!(0==(i))) {
              {
                Ent newent = ent_MakeEnt(numEntsCt);
                if (a2b(newent))
                  {
                    ent_SetNext(newent, bent);
                    bent = newent;
                    entTab[numEntsCt] = newent;
                    ent_SetTag(newent, numEntsCt);
                    numEntsCt = 1+(numEntsCt);
                    if (0==((numEntsCt)%(entTabInc)))
                      {
                        Ent []tmpEntTab = (Ent[]) resizeArray(entTab, (int)((entTabInc)+(numEntsCt)));
                        if (a2b(tmpEntTab))
                          {
                            entTab = tmpEntTab;
                          }
                        else i = 1;
                      }
                  }
                else i = 1;
              }
              {
                i = (i)-1;
              }
            }
            freeEnts = bent;
          }
          unlck(freeEntLck);
          unlck(segChainLck);
          return numEntsCt;
        }
      else if ((maxBlkSize)>(blkSize))
        {
          Console.Error.Write(">>>>ERROR<<<< "+("initWb")+": already initialized with smaller blk-size: "+(maxBlkSize)+">"+(blkSize)+"\n");
          unlck(segChainLck);
          return argerr;
        }
      else {
        Console.Error.Write(""+("initWb")+": already initialized\n");
        unlck(segChainLck);
        return notpres;
      }
    }
    

    public static int finalWb()
    {
      if (a2b(lckTab))
        {
          {
            wb.Seg seg = segChain;
            while (a2b(seg)) {
              lck(segChainLck);
              closeSeg(seg, true);
              unlck(segChainLck);
              {
                seg = segChain;
              }
            }
          }
          {
            int i = numEntsCt;
            while (!(0==(i))) {
              
              entTab[ -1+(i)] = null;
              numEntsCt =  -1+(numEntsCt);
              {
                i = (i)-1;
              }
            }
          }
          {
            int i = numBuks;
            while (!(0==(i))) {
              
              lckTab[(i)-1] = null;
              {
                i = (i)-1;
              }
            }
          }
          
          entTab = null;
          
          lckTab = null;
          
          bukTab = null;
          blkio_Final();
          return success;
        }
      else {
        Console.Error.Write(""+("finalWb")+": already finaled\n");
        blkio_Final();
        return success;
      }
    }
    

    public static int segCntr = 4;
    
    public static wb.Seg segChain = null;
    
    public static Lck segChainLck = makeLck( -3);
    
    /*  Create segment-descriptor and splice into seg-chain. */

    public static wb.Seg newSeg(String filename,String caller)
    {
      if (a2b(lckTab))
        {
          lck(segChainLck);
          {
            wb.Seg sseg = segChain;
            Lloop: 
            {
              if (!(a2b(sseg)))
                goto LmakeIt;
              else if (a2b(seg_Str(sseg))
                  && (filename)==(seg_Str(sseg)))
                {
                  Console.Error.Write(">>>>ERROR<<<< "+(caller)+": segment already open to \""+(filename)+"\"\n");
                  unlck(segChainLck);
                  return null;
                }
              else if ((segChain)==(seg_Nxt(sseg)))
                goto LmakeIt;
              else {
                sseg = seg_Nxt(sseg);
                goto Lloop;
              }
LmakeIt:
              {
                wb.Seg seg = newSegd(segCntr);
                seg_SetStr(seg, filename);
                if (a2b(segChain))
                  {
                    wb.Seg prevSeg = seg_Prv(segChain);
                    seg_SetNxt(prevSeg, seg);
                    seg_SetPrv(seg, prevSeg);
                    seg_SetNxt(seg, segChain);
                    seg_SetPrv(segChain, seg);
                  }
                else {
                  seg_SetNxt(seg, seg);
                  seg_SetPrv(seg, seg);
                }
                seg_SetFlc(seg, new int [flcLen]);
                seg_SetFlcLen(seg, 0);
                segCntr = 1+(segCntr);
                segChain = seg;
                unlck(segChainLck);
                return seg;
              }
            }
          }
        }
      else {
        Console.Error.Write(">>>>ERROR<<<< "+(caller)+": WB not initialized (need to call "+("initWb")+")\n");
        return null;
      }
    }
    
    /*  lock must already be held on seg-chain-lck */

    public static void freeSeg(wb.Seg seg)
    {
      seg_SetPort(seg, null);
      
      seg_SetStr(seg, null);
      
      seg_SetFlc(seg, null);
      seg_SetFlcLen(seg, 0);
      seg_SetUsed(seg, 0);
      if (!(a2b(segChain)))
        {
          Console.Error.Write(">>>>ERROR<<<< "+("freeSeg")+": "+("segChain")+" already empty!\n");
          return;
        }
      else if ((seg_Prv(seg))==(seg))
        {
          if ((seg)!=(segChain))
            Console.Error.Write(">>>>ERROR<<<< "+("freeSeg")+": corrupted "+("segChain")+".\n");
          segChain = null;
          return;
        }
      else {
        wb.Seg nextSeg = seg_Nxt(seg);
        wb.Seg prevSeg = seg_Prv(seg);
        seg_SetNxt(prevSeg, nextSeg);
        seg_SetPrv(nextSeg, prevSeg);
        if ((seg)==(segChain))
          segChain = ((segChain)==(nextSeg)
            ?null
            :nextSeg);
          return;
      }
    }
    

    public static bool checkFile_P(String filename)
    {
      FileStream file = blkio_OpenReadOnlyFile(filename, 0x80);
      byte []tblk = new byte[0x80];
      if (a2b(file))
        {
          bool allok_P = a2b(blkio_Read(file, tblk, 0x80, 0))
          && 0==(str2long(tblk, 0))
          && 0==(str2long(tblk, 4))
          && 0==(str2long(tblk, 8))
          && 0x77==((tblk[0x17] & 0xFF))
          && 0x62==((tblk[0x18] & 0xFF));
          blkio_FileClose(file, 0x80, !((true)));
          return allok_P;
        }
      else return false;
    }
    

    public static wb.Seg openSeg(String filename,bool mutable_P)
    {
      return openSegd(filename, mutable_P, !((true)));
    }
    

    public static wb.Seg openSegd(String filename,bool mutable_P,bool evenIfDirty_P)
    {
      int bsiz = 3*0x80;
      if ((bsiz)>(blkSize))
        {
          Console.Error.Write(">>>>ERROR<<<< unsupported "+("bsiz")+" "+(bsiz)+" > "+(blkSize)+"\n");
          return null;
        }
      else if (!(checkFile_P(filename)))
        return null;
      else {
        wb.Seg seg = newSeg(filename, "openSeg");
        String reason;
        if (!(a2b(seg)))
          return seg;
        else {
          FileStream file = (mutable_P
            ?blkio_OpenModifyFile(filename, bsiz)
            :blkio_OpenReadOnlyFile(filename, bsiz));
          Lloop: 
          if (blkio_PortOpen_P(file, mutable_P))
            {
              seg_SetPort(seg, file);
              seg_SetBsiz(seg, bsiz);
              seg_SetUsed(seg, 2);
              seg_SetFlcLen(seg, (mutable_P
                  ? -1
                  : -2));
              {
                wb.Han han = seg_RtHan(seg);
                byte []tmpStr = new byte[0x100];
                if (err_P(btOpen(seg, 0, han, (wcbSap)+(wcbSar))))
                  {
                    reason = "bt-open 0";
                    goto Lerrout;
                  }
                else if (2!=(btGet(han, bsizByts, 4, tmpStr)))
                  {
                    reason = "BSIZ";
                    goto Lerrout;
                  }
                else if ((bsiz)!=(str2short(tmpStr, 0)))
                  {
                    blkio_FileClose(file, bsiz, mutable_P);
                    bsiz = str2short(tmpStr, 0);
                    if ((bsiz)>(blkSize))
                      {
                        reason = "BSIZ too big.";
                        goto Lerrout;
                      }
                    else {
                      file = (mutable_P
                        ?blkio_OpenModifyFile(filename, bsiz)
                        :blkio_OpenReadOnlyFile(filename, bsiz));
                      goto Lloop;
                    }
                  }
                else {
                  bool dty_P = mutable_P
                  && err_P(btRem(han, clnByts, 3, tmpStr));
                  if (dty_P
                      && !(evenIfDirty_P))
                    {
                      reason = "not cleanly saved; use wbcheck to repair.";
                      goto Lerrout;
                    }
                  else {
                    if (dty_P)
                      Console.Error.Write("WARNING: File \""+(filename)+"\" not cleanly saved.\n");
                    if (4!=(btGet(han, usedByts, 4, tmpStr)))
                      {
                        reason = "USED";
                        goto Lerrout;
                      }
                    else {
                      seg_SetUsed(seg, str2long(tmpStr, 0));
                      if (5!=(btGet(han, fldByts, 3, tmpStr)))
                        {
                          reason = "FLD";
                          goto Lerrout;
                        }
                      else if (err_P(btOpen(seg, str2long(tmpStr, 1), seg_FlHan(seg), wcbSar)))
                        {
                          reason = "FLC";
                          goto Lerrout;
                        }
                      else {
                        if ((han_Typ(seg_FlHan(seg)))!=(frlTyp))
                          Console.Error.Write("Older type freelist - still supported.\n");
                        han_SetWcb(seg_FlHan(seg), wcbSar);
                        return seg;
                      }
                    }
                  }
                }
              }
            }
          else {
            if (blkio_PortOpen_P(file, mutable_P))
              blkio_FileClose(file, bsiz, mutable_P);
            Console.Error.Write(">>>>ERROR<<<< could not open file "+(filename)+"\n");
            freeSeg(seg);
            return null;
          }
        }
Lerrout:
        Console.Error.Write(">>>>ERROR<<<< File \""+(filename)+"\" "+(reason)+"\n");
        if (a2b(seg))
          {
            blkio_FileClose(seg_Port(seg), bsiz, mutable_P);
            freeSeg(seg);
          }
        return null;
      }
    }
    

    public static int closeSeg(wb.Seg seg,bool hammer_P)
    {
      if ((!(a2b(seg))
          || !(a2b(seg_Port(seg)))
          || !(a2b(seg_Str(seg)))
          || 0==(seg_Used(seg))))
        return notpres;
      else {
        flushFlc(seg, 5);
        /*leave only enough blocks to fit in flc in superblock.*/
        if ((seg_FlcLen(seg))>=0)
          {
            byte []tmpStr = new byte[0x14];
            {
              int i =  -1+(seg_FlcLen(seg));
              while (!(0 > (i))) {
                long2str(tmpStr, 4*(i), seg_Flc(seg)[i]);
                {
                  i =  -1+(i);
                }
              }
            }
            btPut(seg_RtHan(seg), flcByts, 3, tmpStr, 4*(seg_FlcLen(seg)));
            seg_SetFlcLen(seg,  -1);
          }
        {
          bool mutable_P = seg_Mutable_P(seg);
          int ans = doSegBuffers(seg, "flushBuffer");
          if ((success_P(ans)
              || hammer_P))
            {
              if (!(success_P(ans)))
                ans = notpres;
              doSegBuffers(seg, "purgeBuffer");
              if (mutable_P)
                {
                  blkio_FlushToFile(seg_Port(seg), !((true)));
                  if (err_P(btWrite(seg_RtHan(seg), clnByts, 3, noByts, 0)))
                    Console.Error.Write("WARNING: mutable file \""+(seg_Str(seg))+"\" already clean?\n");
                }
              btClose(seg_RtHan(seg));
              btClose(seg_FlHan(seg));
              blkio_FileClose(seg_Port(seg), seg_Bsiz(seg), mutable_P);
              freeSeg(seg);
            }
          return ans;
        }
      }
    }
    

    public static byte []dbVersionStr = stringToBytes("wb-2b3");
    
    public static byte []dbAuthorsStr = stringToBytes("A. Jaffer, J. Finger, R. Zito-Wolf");
    

    public static wb.Seg makeSeg(String filename,int bsiz)
    {
      wb.Seg seg = newSeg(filename, "makeSeg");
      if (!(a2b(seg)))
        return seg;
      else if ((bsiz)>(blkSize))
        {
          Console.Error.Write(">>>>ERROR<<<< unsupported "+("bsiz")+" "+(bsiz)+" > "+(blkSize)+"\n");
          unlck(seg_Lck(seg));
          return null;
        }
      else {
        FileStream file = blkio_CreateFile(filename, bsiz);
        if (blkio_PortOpen_P(file, true))
          {
            seg_SetPort(seg, file);
            seg_SetBsiz(seg, bsiz);
            seg_SetUsed(seg, 3);
            seg_SetStr(seg, filename);
            seg_SetFlcLen(seg,  -1);
            {
              wb.Han rtHan = seg_RtHan(seg);
              wb.Han han = seg_FlHan(seg);
              byte []tmpStr = new byte[5];
              if (a2b(btOpenNew(seg, 0, rtHan, (wcbSap)+(wcbSar), dirTyp))
                  && a2b(btOpenNew(seg, 1, han, wcbSap, dirTyp))
                  && a2b(btOpenNew(seg, 2, han, wcbSar, frlTyp)))
                {
                  btPut(rtHan, noByts, 0, dbVersionStr, dbVersionStr.Length);
                  long2str(tmpStr, 0, seg_Used(seg));
                  btPut(rtHan, usedByts, 4, tmpStr, 4);
                  short2str(tmpStr, 0, seg_Bsiz(seg));
                  btPut(rtHan, bsizByts, 4, tmpStr, 2);
                  tmpStr[0] = (byte) (0xff&4);
                  long2str(tmpStr, 1, 1);
                  btPut(rtHan, rootByts, 4, tmpStr, 5);
                  long2str(tmpStr, 1, 2);
                  btPut(rtHan, fldByts, 3, tmpStr, 5);
                  btPut(rtHan, flcByts, 3, noByts, 0);
                  if ((bsiz)>0x80)
                    btPut(rtHan, authorsByts, 7, dbAuthorsStr, dbAuthorsStr.Length);
                  return seg;
                }
              else {
                Console.Error.Write(">>>>ERROR<<<< couldn't allocate ents for file "+(filename)+"\n");
                unlck(seg_Lck(seg));
                closeSeg(seg, true);
                return null;
              }
            }
          }
        else {
          Console.Error.Write(">>>>ERROR<<<< couldn't create new file "+(filename)+"\n");
          unlck(seg_Lck(seg));
          return null;
        }
      }
    }
    

    public static int btOpen(wb.Seg seg,int blkNum,wb.Han han,int wcb)
    {
      if (a2b(seg)
          && a2b(seg_Str(seg)))
        {
          Ent ent = getEnt(seg, blkNum, accread);
          if (!(a2b(ent)))
            return argerr;
          else if (!(root_P(ent_Blk(ent))))
            {
              releaseEnt(ent, accread);
              Console.Error.Write(">>>>ERROR<<<< "+("btOpen")+": not a root "+(seg_Id(seg))+":"+(blkNum)+"\n");
              return argerr;
            }
          else {
            btOpenInitHan(han, ent, wcb);
            releaseEnt(ent, accread);
            return han_Typ(han);
          }
        }
      else return argerr;
    }
    

    public static void btOpenInitHan(wb.Han han,Ent ent,int wcb)
    {
      int typ = blk_Typ(ent_Blk(ent));
      wb.Seg seg = ent_Seg(ent);
      int blkNum = ent_Id(ent);
      han_SetSeg(han, seg);
      han_SetNum(han, blkNum);
      han_SetLast(han, blkNum);
      han_SetTyp(han, typ);
      if ((typ)==(dirTyp))
        wcb = (wcb)|((wcbSap)+(wcbSar));
      han_SetWcb(han, wcb);
      return;
    }
    
    /*  Does calling GET-BUK-WAIT admit the possiblity of deadly embrace? */

    public static bool btOpenNew(wb.Seg seg,int blkNum,wb.Han han,int wcb,int typ)
    {
      if (0 > (blkNum))
        {
          Console.Error.Write(">>>>ERROR<<<< negative block number "+(blkNum)+"\n");
          return false;
        }
      else {
        Ent ent = tryGetFreeEnt(null,  -1);
        while (!(a2b(ent))) {
          {
            ent = tryGetFreeEnt(null,  -1);
          }
        }
        initLeafBlk(ent_Blk(ent), blkNum, typ);
        blk_SetTime(ent_Blk(ent), (int)(DateTime.Now.Ticks/10000000L));
        ent_SetNext(ent, getBukWait(seg_Id(seg), blkNum));
        setBuk(seg_Id(seg), blkNum, ent);
        ent_SetAcc(ent, accwrite);
        ent_SetSeg(ent, seg);
        ent_SetId(ent, blkNum);
        ent_SetAge(ent,  -127);
        ent_SetDty(ent, true);
        ent_SetPus(ent, 0);
        ent_SetRef(ent, 1);
        relBuk(seg_Id(seg), blkNum);
        btOpenInitHan(han, ent, wcb);
        ents_EntWrite(ent);
        releaseEnt(ent, accwrite);
        return (true);
      }
    }
    

    public static int btCreate(wb.Seg seg,int typ,wb.Han han,int wcb)
    {
      if (a2b(seg)
          && a2b(han))
        {
          Ent ent = createNewBlkEnt(seg);
          if (a2b(ent))
            {
              int blkNum = ent_Id(ent);
              initLeafBlk(ent_Blk(ent), blkNum, typ);
              ent_SetPus(ent, 0);
              btOpenInitHan(han, ent, wcb);
              ents_EntWrite(ent);
              releaseEnt(ent, accwrite);
              return success;
            }
          else return noroom;
        }
      else return argerr;
    }
    

    public static int btClose(wb.Han han)
    {
      if (a2b(han))
        {
          han_SetSeg(han, null);
          han_SetNum(han, 0);
          han_SetTyp(han, 0);
          han_SetLast(han, 0);
          return success;
        }
      else return argerr;
    }
    
    /* This file was generated by scm2cs from source file "blink.scm" */
    /*  "blink.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000, 2003, 2010 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */

    /*  TBD: */
    /*  allow different size blks for index and leaves. */
    /*  add multi-record operations */

    /*  uncomment for newlines at end of blocks: */

    /*  uncomment for extra check in REROOT! and path tracing in BLK:FIND-POS. */
    /* (provide 'DEBUG) */



    /*  BLK ACCESS AND MODIFICATION ROUTINES */


    public static void short2str(byte []str,int pos,int cint)
    {
      str[(pos)+1] = (byte) (0xff&((cint)&0xff));
      str[(pos)+0] = (byte) (0xff&((cint)>>8));
      return;
    }
    
    public static int str2short(byte []str,int pos)
    {
      return ((str[(pos)+1] & 0xFF))|(((str[pos] & 0xFF))<<8);
    }
    

    public static void long2str(byte []str,int pos,int clong)
    {
      str[(pos)+3] = (byte) (0xff&((clong)&0xff));
      str[(pos)+2] = (byte) (0xff&(((clong)>>8)&0xff));
      str[(pos)+1] = (byte) (0xff&(((clong)>>0x10)&0xff));
      str[(pos)+0] = (byte) (0xff&((clong)>>0x18));
      return;
    }
    
    public static int str2long(byte []str,int pos)
    {
      return ((str[(pos)+3] & 0xFF))|((((str[(pos)+2] & 0xFF))|((((str[(pos)+1] & 0xFF))|(((str[pos] & 0xFF))<<8))<<8))<<8);
    }
    

    public static int setField(byte []blk,int bPos,byte []valStr,int fPos,int fLen)
    {
      setFieldLen(blk, bPos, fLen);
      subbytesMove(valStr, fPos, (fPos)+(fLen), blk, 1+(bPos));
      return (fLen)+1+(bPos);
    }
    

    public static byte []leafSplitKeyStr = bytes((byte)(0xff),(byte)(0x30));
    

    public static void initLeafBlk(byte []nblk,int bnum,int typ)
    {
      nblk[(blkSize)-1] = (byte) (0xff&0xa);
      blk_SetId(nblk, bnum);
      blk_SetNxtId(nblk, 0);
      blk_SetTopId(nblk, bnum);
      blk_SetTime(nblk, 0);
      blk_SetLevel(nblk, leaf);
      blk_SetTyp(nblk, typ);
      setFieldLen(nblk, blkDataStart, 0);
      setField(nblk, (blkDataStart)+1, leafSplitKeyStr, 0, 2);
      blk_SetEnd(nblk, (blkDataStart)+(((typ)==(seqTyp)
           ?0
           :4)));
      return;
    }
    
    /* RBLK= the root block, NBLK= new block to hold root's data, BNUM= its ID */


    public static void reroot(byte []rblk,byte []nblk,int bnum,int bsiz)
    {
      int rpos = blkDataStart;
      subbytesMove(rblk, 4, bsiz, nblk, 4);
      blk_SetNxtId(rblk, 0);
      blk_SetLevel(rblk, (blk_Level(rblk))+1);
      setFieldLen(rblk, rpos, 0);
      rpos = setField(rblk, (rpos)+1, leafSplitKeyStr, 0, 2);
      rblk[(rpos)-1] = (byte) (0xff&((blk_Level(rblk))-1));
      rpos = setField(rblk, rpos, nblk, 0, 4);
      setFieldLen(rblk, rpos, 1);
      rpos = setField(rblk, (rpos)+1, leafSplitKeyStr, 0, 1);
      rblk[(rpos)-1] = (byte) (0xff&(blk_Level(rblk)));
      blk_SetEnd(rblk, rpos);
      return;
    }
    

    public static void initNextBlk(byte []blk,byte []nblk)
    {
      nblk[(blkSize)-1] = (byte) (0xff&0xa);
      blk_SetNxtId(nblk, blk_NxtId(blk));
      blk_SetTopId(nblk, blk_TopId(blk));
      blk_SetLevel(nblk, blk_Level(blk));
      blk_SetTyp(nblk, blk_Typ(blk));
      blk_SetNxtId(blk, blk_Id(nblk));
      setFieldLen(nblk, blkDataStart, 0);
      setField(nblk, (blkDataStart)+1, noByts, 0, 0);
      blk_SetEnd(nblk, (blkDataStart)+2);
      return;
    }
    

    public static int splitKeyPos(byte []blk)
    {
      int bEnd = blk_End(blk);
      {
        int bPos = blkDataStart;
        Llp: 
        {
          int sPos = nextField(blk, 1+(bPos));
          if ((sPos)==(bEnd))
            return bPos;
          else if ((sPos)<(bEnd))
            {
              bPos = nextCnvpair(blk, bPos);
              goto Llp;
            }
          else {
            Console.Error.Write(">>>>ERROR<<<< "+("splitKeyPos")+": blk past end "+(blk_Id(blk))+" "+(sPos)+"\n");
            return 0;
          }
        }
      }
    }
    

    /*  Pass in len; -1 to seek END-OF-CHAIN; -2 for START-OF-CHAIN. */
    /*  If key-str = END-OF-CHAIN, then return PASTEND @ split-pos. */
    /*  If key-str = START-OF-CHAIN, then return QPASTP @ blk-data-start. */
    /*  Otherwise, can return any of 5 match conditions. */

    /*  As we go through blk looking for key, KEY-POS (k-pos) is the */
    /*  number of characters matching between key and blk. */


    public static bool blk_FindPos(byte []blk,byte []keyStr,int kLen,int []pkt)
    {
      if ((kLen)<0)
        {
          if ((kLen)==(endOfChain))
            {
              int skpos = splitKeyPos(blk);
              pkt_Pack(pkt, (endOfChain_P(blk)
                  ?qpastp
                  :pastend), skpos, 0, blkPrevKey(blk, skpos));
            }
          else pkt_Pack(pkt, qpastp, blkDataStart, 0, 0);
          return (true);
        }
      else {
        int kPos = 0;
        int bEnd = blk_End(blk);
        {
          int bPos = blkDataStart;
          int pPos = 0;
          Lchknxt: 
          if ((fieldLen(blk, bPos))<(kPos))
            {
              pkt_Pack(pkt, qpastp, bPos, kPos, pPos);
              return (true);
            }
          else if ((fieldLen(blk, bPos))>(kPos))
            {
              int sPos = nextField(blk, (bPos)+1);
              if ((sPos)<(bEnd))
                {
                  int T_bPos = nextCnvpair(blk, bPos);
                  pPos = bPos;
                  bPos = T_bPos;
                  goto Lchknxt;
                }
              else if ((sPos)==(bEnd))
                {
                  pkt_Pack(pkt, pastend, bPos, kPos, pPos);
                  return (true);
                }
              else {
                Console.Error.Write(">>>>ERROR<<<< "+("blkFindPos")+"1: blk past end "+(blk_Id(blk))+" "+(sPos)+"\n");
                return false;
              }
            }
          else {
            int i = (bPos)+2;
            int fLen = fieldLen(blk, (bPos)+1);
            Lmchlp: 
            if ((kPos)>=(kLen))
              if ((fLen)>0)
                {
                  pkt_Pack(pkt, pastp, bPos, kPos, pPos);
                  return (true);
                }
              else {
                int sPos = nextField(blk, (bPos)+1);
                if ((sPos)<(bEnd))
                  {
                    pkt_Pack(pkt, match, bPos, kLen, pPos);
                    return (true);
                  }
                else if ((sPos)==(bEnd))
                  {
                    pkt_Pack(pkt, matchend, bPos, kPos, pPos);
                    return (true);
                  }
                else {
                  Console.Error.Write(">>>>ERROR<<<< "+("blkFindPos")+"2: blk past end "+(blk_Id(blk))+" "+(sPos)+"\n");
                  return false;
                }
              }
            else if (((fLen)<=0
                || ((blk[i] & 0xFF))<((keyStr[kPos] & 0xFF))))
              {
                int sPos = nextField(blk, (bPos)+1);
                if ((sPos)<(bEnd))
                  {
                    int T_bPos = nextCnvpair(blk, bPos);
                    pPos = bPos;
                    bPos = T_bPos;
                    goto Lchknxt;
                  }
                else if ((sPos)==(bEnd))
                  {
                    pkt_Pack(pkt, pastend, bPos, kPos, pPos);
                    return (true);
                  }
                else {
                  Console.Error.Write(">>>>ERROR<<<< "+("blkFindPos")+"3: blk past end "+(blk_Id(blk))+" "+(sPos)+"\n");
                  return false;
                }
              }
            else if (((blk[i] & 0xFF))>((keyStr[kPos] & 0xFF)))
              {
                pkt_Pack(pkt, ((kPos)>(fieldLen(blk, bPos))
                    ?pastp
                    :qpastp), bPos, kPos, pPos);
                return (true);
              }
            else {
              kPos = (kPos)+1;
              {
                i = 1+(i);
                fLen = (fLen)-1;
                goto Lmchlp;
              }
            }
          }
        }
      }
    }
    
    /*  Can return QPASTP or PASTP @ any key or MATCH at non-split key. */


    public static Ent chainFind(Ent ent,int accmode,byte []keyStr,int kLen,int []pkt)
    {
    LchainFind:while (true) {
      {
        byte []blk = ent_Blk(ent);
        if (!(a2b(blk_FindPos(blk, keyStr, kLen, pkt))))
          {
            releaseEnt(ent, accmode);
            return null;
          }
        else if (!(((pkt_MatchType(pkt))==(matchend)
                || (pkt_MatchType(pkt))==(pastend))))
          return ent;
        else if (endOfChain_P(blk))
          {
            Console.Error.Write(">>>>ERROR<<<< "+("chainFind")+": matched or past end of chain "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+"\n");
            pkt_SetMatchType(pkt, qpastp);
            return ent;
          }
        else {
          chainsToNext = 1+(chainsToNext);
          ent = switchEnt(ent, accmode, blk_NxtId(blk), accmode);
          if (a2b(ent))
            goto LchainFind;
          else return null;
        }
      }
    }
    }
    
    /*  find-ent is always called with ent = (get-ent <seg> <blk-num> ACCNONE). */
    /*  TBD - These calls could be colapsed. */
    /*  should be called with LAST-LEVEL=-1 */


    public static Ent findEnt(Ent ent,int desiredLevel,int lastLevel,byte []keyStr,int kLen)
    {
    LfindEnt:while (true) {
      if (a2b(ent))
        if (ents_EntUpdateAccess_P(ent, accnone, accread))
          {
            byte []blk = ent_Blk(ent);
            int blvl = blk_Level(blk);
            if ((blvl)==(desiredLevel))
              return ent;
            else if ((blvl)<(desiredLevel))
              {
                Console.Error.Write(">>>>ERROR<<<< bad blk level "+(blvl)+" (des="+(desiredLevel)+") in "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))
   +"\n");
                return null;
              }
            else if ((lastLevel)>=0
                && (blvl)!=((lastLevel)-1))
              {
                Console.Error.Write(">>>>ERROR<<<< bad blk level "+(blvl)+" last="+(lastLevel)+" in "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))
   +"\n");
                return null;
              }
            else {
              int []pkt = new int[pktSize];
              ent = chainFind(ent, accread, keyStr, kLen, pkt);
              if (a2b(ent))
                {
                  int pos = nextField(blk, 1+(pkt_MatchPos(pkt)));
                  blk = ent_Blk(ent);
                  {
                    int caseVal18 = pkt_MatchType(pkt);
                    if ((qpastp == caseVal18)|| (pastp == caseVal18)){
                      ;
                    }
                    else if ((match == caseVal18)){
                      if ((blk_End(blk))==(pos))
                        {
                          pos = pkt_MatchPos(pkt);
                        }
                      else pos = nextField(blk, pos);
                    }
                  else {
                      pos = 0;
                    }
                  }
                  if (0==(pos))
                    {
                      Console.Error.Write(">>>>ERROR<<<< "+("findEnt")+": bad-MATCH-TYPE "+(pkt_MatchPos(pkt))+" blk "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))
   +"\n");
                      return null;
                    }
                  else {
                    pos = nextField(blk, 1+(pkt_MatchPos(pkt)));
                    {
                      ent = switchEnt(ent, accread, ((blk_End(blk))==(pos)
                          ?(endOfChain_P(blk)
                            ?str2long(blk,  -6+(pos))
                            :blk_NxtId(blk))
                          :str2long(blk, 1+(pos))), accnone);
                      lastLevel = ((blk_End(blk))==(pos)
                          && !(endOfChain_P(blk))
                        ?(blk_Level(blk))+1
                        :blk_Level(blk));
                      goto LfindEnt;
                    }
                  }
                }
              else return null;
            }
          }
        else return null;
      else return null;
    }
    }
    

    public static int blkPrevKey(byte []blk,int pos)
    {
      {
        int bPos = blkDataStart;
        int pPos = 0;
        while (!((bPos)>=(pos))) {
          {
            int T_bPos = nextCnvpair(blk, bPos);
            pPos = bPos;
            bPos = T_bPos;
          }
        }
        if ((bPos)>(pos))
          {
            Console.Error.Write(">>>>ERROR<<<< "+("blkPrevKey")+": blk past end "+(blk_Id(blk))+" "+(pPos)+"\n");
            return 0;
          }
        else return pPos;
      }
    }
    
    /*  DATA BASE OPERATIONS */


    public static int getThisVal(byte []blk,int bPos,byte []ansStr)
    {
      bPos = nextField(blk, (bPos)+1);
      {
        int alen = fieldLen(blk, bPos);
        subbytesMove(blk, (bPos)+1, (bPos)+1+(alen), ansStr, 0);
        return alen;
      }
    }
    

    public static int getThisKey(byte []blk,int bPos,byte []keyStr,byte []ansStr,Ent ent,int kLen,int []pkt)
    {
      {
        int bEnd = blk_End(blk);
        int sPos = nextField(blk, (bPos)+1);
        if ((sPos)<(bEnd))
          {
            int fPos = fieldLen(blk, bPos);
            int fSiz = fieldLen(blk, (bPos)+1);
            int alen = (fPos)+(fSiz);
            if ((keyStr)!=(ansStr))
              subbytesMove(keyStr, 0, fPos, ansStr, 0);
            subbytesMove(blk, (bPos)+2, (bPos)+2+(fSiz), ansStr, fPos);
            releaseEnt(ent, accread);
            return alen;
          }
        else if ((sPos)!=(bEnd))
          {
            Console.Error.Write(">>>>ERROR<<<< "+("chainNext")+": blk past end "+(blk_Id(blk))+" "+(sPos)+"\n");
            releaseEnt(ent, accread);
            return strangerr;
          }
        else if (endOfChain_P(blk))
          {
            releaseEnt(ent, accread);
            return notpres;
          }
        else {
          ent = switchEnt(ent, accread, blk_NxtId(blk), accread);
          if (a2b(ent))
            ent = chainFind(ent, accread, keyStr, kLen, pkt);
          if (a2b(ent))
            return chainNext(ent, keyStr, kLen, ansStr, pkt);
          else return unkerr;
        }
      }
    }
    

    public static int chainNext(Ent ent,byte []keyStr,int kLen,byte []ansStr,int []pkt)
    {
      pkt_SetBlkToCache(pkt, ent_Id(ent));
      {
        int caseVal6 = pkt_MatchType(pkt);
        if ((pastp == caseVal6)|| (qpastp == caseVal6)){
          return getThisKey(ent_Blk(ent), pkt_MatchPos(pkt), keyStr, ansStr, ent, kLen, pkt);
        }
        else if ((match == caseVal6)){
          return getThisKey(ent_Blk(ent), nextCnvpair(ent_Blk(ent), pkt_MatchPos(pkt)), keyStr, ansStr, ent, kLen, pkt);
        }
      else {
          releaseEnt(ent, accread);
          return notpres;
        }
      }
    }
    
    /*  To shrink a block give growth less than 0 and location equals */
    /*  position after deleted. */
    /*  blk-change-size returns #f if not enough room */

    public static bool blk_ChangeSize(byte []blk,int loc,int growth,int bsiz)
    {
      int bEnd = blk_End(blk);
      if (0==(growth))
        return (true);
      else if (((bEnd)+(growth))>(bsiz))
        return false;
      else if (0 > (growth))
        {
          subbytesMoveLeft(blk, loc, bEnd, blk, (loc)+(growth));
          blk_SetEnd(blk, (bEnd)+(growth));
          return (true);
        }
      else {
        subbytesMoveRight(blk, loc, bEnd, blk, (loc)+(growth));
        blk_SetEnd(blk, (bEnd)+(growth));
        return (true);
      }
    }
    

    public static bool blk_RemoveKeyAndVal(byte []blk,int bPos,int bsiz)
    {
      int nbPos = nextCnvpair(blk, bPos);
      if ((fieldLen(blk, nbPos))>(fieldLen(blk, bPos)))
        {
          int delkPos = (fieldLen(blk, nbPos))-(fieldLen(blk, bPos));
          setFieldLen(blk, 1+(bPos), (fieldLen(blk, 1+(nbPos)))+(delkPos));
          return blk_ChangeSize(blk, 2+(nbPos), ((bPos)-(nbPos))+(delkPos), bsiz);
        }
      else return blk_ChangeSize(blk, nbPos, (bPos)-(nbPos), bsiz);
    }
    
    /*  return #t if operation was succsessful; #f if not */
    /*  */
    /*  Note the splitting of OBLK into OBLK+NBLK by inserting the split */
    /*  key of each block into parent. */
    /*  */
    /*  Note this routine does not check if the key(s) have already been */
    /*  (perhaps by another process) inserted into parent. */
    /*  */
    /*  unfortunately, the right way to do this requires that the update */
    /*  look just like a PUT of the NKEY-STR with value N-ID, albeit one */
    /*  that then swaps the values of the new entry and the one */
    /*  following... */
    /*  */
    /*  The SCREW-CASE occurs when the key is inserted at the endof the */
    /*  block, so that we have to get access to the next (NON-EMPTY!) */
    /*  block to make the swap... */


    public static bool deferInsertUpdates_P = false;
    

    public static bool parentInsertUpdate(wb.Seg seg,int topId,int level,byte []nkeyStr,int nkLen,int nId)
    {
      int []pkt = new int[pktSize];
      {
        Ent ent = findEnt(getEnt(seg, topId, accnone), 1+(level),  -1, nkeyStr, nkLen);
        Ent xent = null;
        bool screwCase_P = false;
        byte []blkidstr = new byte[4];
        byte []blk = null;
        if (a2b(ent))
          {
            long2str(blkidstr, 0, nId);
            if (ents_EntUpdateAccess_P(ent, accread, accwrite))
              {
                ent = chainFind(ent, accwrite, nkeyStr, nkLen, pkt);
                blk = ent_Blk(ent);
              }
            else {
              releaseEnt(ent, accread);
              ent = null;
            }
            if (a2b(ent)
                && atSplitKeyPos_P(blk, pkt_MatchPos(pkt)))
              {
                screwCase_P = (true);
                xent = nextNonemptyEnt(ent_Seg(ent), blk_NxtId(blk));
                if (!(a2b(xent)))
                  Console.Error.Write(">>>>ERROR<<<< No next key found for index insert "+(seg_Id(ent_Seg(ent)))+":"+(blk_Id(blk))+"\n");
              }
            if (!(deferInsertUpdates_P)
                && a2b(ent)
                && (!(screwCase_P)
                       || a2b(xent))
                && a2b(chainPut(ent, nkeyStr, nkLen, blkidstr, 4, pkt, xent, wcbSar)))
              return (true);
            else {
              Console.Error.Write("WARNING: "+("parentInsertUpdate")+": couldn't update parent n-id="+(nId)+" nk-len="+(nkLen)+"\n");
              deferredInserts = 1+(deferredInserts);
              if (a2b(ent))
                releaseEnt(ent, accwrite);
              return false;
            }
          }
        else return false;
      }
    }
    
    /*  only valid if called with POS=position of some KEY */

    public static bool atSplitKeyPos_P(byte []blk,int pos)
    {
      return (blk_End(blk))==(nextField(blk, 1+(pos)));
    }
    

    public static Ent nextNonemptyEnt(wb.Seg seg,int blknum)
    {
      if ((blknum)<=0)
        return null;
      else {
        Ent xent = getEnt(seg, blknum, accread);
        Lloop: 
        if (a2b(xent))
          {
            ents_EntUpdateAccess_P(xent, accread, accwrite);
          }
        else ;
        if (!(a2b(xent)))
          return null;
        else if (!(blkEmpty_P(ent_Blk(xent))))
          return xent;
        else if (0==(blk_NxtId(ent_Blk(xent))))
          {
            releaseEnt(xent, accwrite);
            return null;
          }
        else {
          xent = switchEnt(xent, accwrite, blk_NxtId(ent_Blk(xent)), accwrite);
          goto Lloop;
        }
      }
    }
    
    /*  Note: CFP must NOT return the split key position IFF at a LEAF */
    /*  RECON-THIS-KEY returns the data in KEY and its length as its return value. */
    /*  END-OF-CHAIN (-1) is returned if the key reconstructed is the end-of-file mark */
    /*  k-len is now used correctly to signal a potential overflow */


    public static int reconThisKey(byte []blk,int pos,byte []keyStr,int kPos,int kLen)
    {
      {
        int bPos = blkDataStart;
        int kSize = 0;
        while (!((bPos)>(pos))) {
          if ((kSize)>(fieldLen(blk, bPos))
              && ((blk[(bPos)+2] & 0xFF))<=((keyStr[(kPos)+(fieldLen(blk, bPos))] & 0xFF)))
            Console.Error.Write(">>>>ERROR<<<< bad key sequence "+(blk_Id(blk))+" @ "+(bPos)+"\n");
          kSize = (fieldLen(blk, bPos))+(fieldLen(blk, 1+(bPos)));
          if ((kSize)>=(kLen))
            Console.Error.Write(">>>>ERROR<<<< not-enough-room "+(kLen)+"\n");
          subbytesMove(blk, (bPos)+2, (bPos)+2+(fieldLen(blk, 1+(bPos))), keyStr, (kPos)+(fieldLen(blk, bPos)));
          bPos = nextField(blk, 1+(bPos));
          if ((bPos)<(blk_End(blk)))
            bPos = nextField(blk, bPos);
          {
          }
        }
        return kSize;
      }
    }
    

    public static bool blk_InsertAndAdjust(byte []blk,int bPos,int kPos,byte []keyStr,int kLen,byte []valStr,int vLen,int bsiz)
    {
      {
        int oldkPos = fieldLen(blk, bPos);
        int oldilen = fieldLen(blk, 1+(bPos));
        int ilen = (kLen)-(oldkPos);
        if (a2b(blk_ChangeSize(blk, bPos, 2+((kLen)-(kPos))+1+(vLen), bsiz)))
          {
            bPos = 1+(bPos);
            bPos = setField(blk, bPos, keyStr, oldkPos, ilen);
            bPos = setField(blk, bPos, valStr, 0, vLen);
            setFieldLen(blk, bPos, kPos);
            setFieldLen(blk, (bPos)+1, (oldilen)-((kPos)-(oldkPos)));
            return (true);
          }
        else return false;
      }
    }
    

    public static bool blk_SimpleInsert(byte []blk,int bPos,int kPos,byte []keyStr,int kLen,byte []valStr,int vLen,int bsiz)
    {
      int ilen = (kLen)-(kPos);
      if (a2b(blk_ChangeSize(blk, bPos, 3+(vLen)+(ilen), bsiz)))
        {
          setFieldLen(blk, bPos, kPos);
          bPos = 1+(bPos);
          bPos = setField(blk, bPos, keyStr, kPos, ilen);
          setField(blk, bPos, valStr, 0, vLen);
          return (true);
        }
      else return false;
    }
    

    public static bool blk_ChangeExistingValue(byte []blk,int bPos,byte []keyStr,int kLen,byte []valStr,int vLen,int bsiz)
    {
      int ovLen = 0;
      int vPos = nextField(blk, 1+(bPos));
      ovLen = fieldLen(blk, vPos);
      if (a2b(blk_ChangeSize(blk, (vPos)+(ovLen)+1, (vLen)-(ovLen), bsiz)))
        {
          setField(blk, vPos, valStr, 0, vLen);
          return (true);
        }
      else return false;
    }
    
    /*  leaf-splits are called with ACCWRITE on blk and return without it. */

    public static int valLeafSplit(byte []blk,byte []nblk,int bPos,byte []keyStr,int kPos,int kLen,byte []valStr,int vLen)
    {
      {
        int vPos = nextField(blk, 1+(bPos));
        int sPos = nextField(blk, vPos);
        int bEnd = blk_End(blk);
        setFieldLen(nblk, blkDataStart, 0);
        if (((bEnd)-(sPos))>((vPos)-(blkDataStart)))
          {
            int mLen = fieldLen(blk, sPos);
            int fChr = (blk[(sPos)+2] & 0xFF);
            setFieldLen(nblk, (blkDataStart)+1, (mLen)+(fieldLen(blk, 1+(sPos))));
            subbytesMove(keyStr, 0, mLen, nblk, (blkDataStart)+2);
            subbytesMove(blk, (sPos)+2, bEnd, nblk, (blkDataStart)+(mLen)+2);
            blk_SetEnd(nblk, ((bEnd)-(sPos))+(mLen)+(blkDataStart));
            bPos = setField(blk, vPos, valStr, 0, vLen);
            blk[(bPos)+2] = (byte) (0xff&(fChr));
            setFieldLen(blk, bPos, mLen);
          }
        else {
          int nbPos = (blkDataStart)+1;
          nbPos = setField(nblk, nbPos, keyStr, 0, kLen);
          nbPos = setField(nblk, nbPos, valStr, 0, vLen);
          subbytesMove(blk, sPos, bEnd, nblk, nbPos);
          blk_SetEnd(nblk, (nbPos)+((bEnd)-(sPos)));
        }
        setFieldLen(blk, (bPos)+1, 1);
        blk_SetEnd(blk, (bPos)+3);
        return bPos;
      }
    }
    

    public static int qpastpLeafSplit(byte []blk,byte []nblk,int bPos,byte []keyStr,int kPos,int kLen,byte []valStr,int vLen)
    {
      {
        int bEnd = blk_End(blk);
        setFieldLen(nblk, blkDataStart, 0);
        if (((bEnd)-(bPos))>((bPos)-(blkDataStart)))
          {
            int mLen = fieldLen(blk, bPos);
            int fChr = (blk[(bPos)+2] & 0xFF);
            setFieldLen(nblk, (blkDataStart)+1, (mLen)+(fieldLen(blk, 1+(bPos))));
            subbytesMove(keyStr, 0, mLen, nblk, (blkDataStart)+2);
            subbytesMove(blk, (bPos)+2, bEnd, nblk, (blkDataStart)+(mLen)+2);
            blk_SetEnd(nblk, ((bEnd)-(bPos))+(mLen)+(blkDataStart));
            setFieldLen(blk, bPos, kPos);
            bPos = setField(blk, (bPos)+1, keyStr, kPos, (kLen)-(kPos));
            bPos = setField(blk, bPos, valStr, 0, vLen);
            blk[(bPos)+2] = (byte) (0xff&(fChr));
            setFieldLen(blk, bPos, mLen);
          }
        else {
          int nbPos = (blkDataStart)+1;
          nbPos = setField(nblk, nbPos, keyStr, 0, kLen);
          nbPos = setField(nblk, nbPos, valStr, 0, vLen);
          subbytesMove(blk, bPos, bEnd, nblk, nbPos);
          blk_SetEnd(nblk, (nbPos)+((bEnd)-(bPos)));
          setFieldLen(blk, bPos, kPos);
          blk[(bPos)+2] = (byte) (0xff&((keyStr[kPos] & 0xFF)));
        }
        setFieldLen(blk, (bPos)+1, 1);
        blk_SetEnd(blk, (bPos)+3);
        return bPos;
      }
    }
    

    public static int pastpLeafSplit(byte []blk,byte []nblk,int bPos,byte []keyStr,int kPos,int kLen,byte []valStr,int vLen)
    {
      {
        int mLen = fieldLen(blk, bPos);
        int bEnd = blk_End(blk);
        setFieldLen(nblk, blkDataStart, 0);
        if (((bEnd)-(bPos))>((bPos)-(blkDataStart)))
          {
            int fChr = (blk[(bPos)+2+((kPos)-(fieldLen(blk, bPos)))] & 0xFF);
            setFieldLen(nblk, (blkDataStart)+1, (mLen)+(fieldLen(blk, 1+(bPos))));
            subbytesMove(keyStr, 0, mLen, nblk, (blkDataStart)+2);
            subbytesMove(blk, (bPos)+2, bEnd, nblk, (blkDataStart)+(mLen)+2);
            blk_SetEnd(nblk, ((bEnd)-(bPos))+(mLen)+(blkDataStart));
            setFieldLen(blk, bPos, mLen);
            bPos = setField(blk, (bPos)+1, keyStr, mLen, (kLen)-(mLen));
            bPos = setField(blk, bPos, valStr, 0, vLen);
            blk[(bPos)+2] = (byte) (0xff&(fChr));
            setFieldLen(blk, bPos, kPos);
          }
        else {
          int nbPos = (blkDataStart)+1;
          int cPos = (bPos)+2+((kPos)-(mLen));
          nbPos = setField(nblk, nbPos, keyStr, 0, kLen);
          nbPos = setField(nblk, nbPos, valStr, 0, vLen);
          setFieldLen(nblk, nbPos, kPos);
          setFieldLen(nblk, (nbPos)+1, ((fieldLen(blk, 1+(bPos)))+(mLen))-(kPos));
          subbytesMove(blk, cPos, bEnd, nblk, (nbPos)+2);
          blk_SetEnd(nblk, (nbPos)+2+((bEnd)-(cPos)));
        }
        setFieldLen(blk, (bPos)+1, 1);
        blk_SetEnd(blk, (bPos)+3);
        return bPos;
      }
    }
    

    public static int dummyLeafSplit(byte []blk,byte []nblk,int bPos,byte []keyStr,int kPos,int kLen,byte []valStr,int vLen)
    {
      Console.Error.Write(">>>>ERROR<<<< "+("dummyLeafSplit")+": bad-MATCH-TYPE blk "+(blk_Id(blk))+"\n");
      return 0;
    }
    

    public static bool chainPut(Ent ent,byte []keyStr,int kLen,byte []valStr,int vLen,int []pkt,Ent xent,int wcb)
    {
      {
        byte []blk = ent_Blk(ent);
        int blklev = blk_Level(blk);
        bool index_P = (blklev)>(leaf);
        int rootId = blk_TopId(blk);
        Ent nent = null;
        Ent nrent = null;
        wb.Seg seg = ent_Seg(ent);
        int bsiz = seg_Bsiz(seg);
        bool result_P = false;
        bool split_P = false;
        Ent nkeyEnt = ent;
        int nkeyPos = pkt_MatchPos(pkt);
        Ent okeyEnt = ent;
        int okeyPos = blkDataStart;
        int nId = 0;
        int sPos = 0;
        byte []splitStr = new byte[0x100];
        int sLen = 0;
        pkt_SetBlkToCache(pkt, ent_Id(ent));
        if ((pkt_MatchType(pkt))==(pastp)
            && a2b(blk_InsertAndAdjust(blk, pkt_MatchPos(pkt), pkt_KeyPos(pkt), keyStr, kLen, valStr, vLen, bsiz)))
          {
            result_P = (true);
          }
        else if ((pkt_MatchType(pkt))==(qpastp)
            && a2b(blk_SimpleInsert(blk, pkt_MatchPos(pkt), pkt_KeyPos(pkt), keyStr, kLen, valStr, vLen, bsiz)))
          {
            result_P = (true);
          }
        else if ((pkt_MatchType(pkt))==(match)
            && a2b(blk_ChangeExistingValue(blk, pkt_MatchPos(pkt), keyStr, kLen, valStr, vLen, bsiz)))
          {
            result_P = (true);
          }
        else 
        nent = createNewBlkEnt(seg);
        if (!(a2b(nent)))
          ;
        else {
          split_P = (true);
          {
            byte []nblk = ent_Blk(nent);
            nId = ent_Id(nent);
            initNextBlk(blk, nblk);
            blockSplits = (blockSplits)+1;
            {
              int caseVal12 = pkt_MatchType(pkt);
              if ((pastp == caseVal12)){
                sPos = pastpLeafSplit(blk, nblk, pkt_MatchPos(pkt), keyStr, pkt_KeyPos(pkt), kLen, valStr, vLen);
              }
              else if ((qpastp == caseVal12)){
                sPos = qpastpLeafSplit(blk, nblk, pkt_MatchPos(pkt), keyStr, pkt_KeyPos(pkt), kLen, valStr, vLen);
              }
              else if ((match == caseVal12)){
                sPos = valLeafSplit(blk, nblk, pkt_MatchPos(pkt), keyStr, pkt_KeyPos(pkt), kLen, valStr, vLen);
              }
            else {
                sPos = dummyLeafSplit(blk, nblk, pkt_MatchPos(pkt), keyStr, pkt_KeyPos(pkt), kLen, valStr, vLen);
              }
            }
            sLen = 1+(fieldLen(blk, sPos));
            subbytesMove(nblk, (blkDataStart)+2, 1+(fieldLen(blk, sPos))+((blkDataStart)+2), splitStr, 0);
            if (index_P)
              {
                okeyEnt = nent;
                if ((pkt_MatchPos(pkt))!=(sPos))
                  {
                    splitIndexInserts = 1+(splitIndexInserts);
                  }
                else {
                  okeyPos = nextCnvpair(nblk, blkDataStart);
                  nkeyEnt = nent;
                  nkeyPos = blkDataStart;
                }
              }
            if ((pkt_MatchPos(pkt))==(sPos))
              pkt_SetBlkToCache(pkt, ent_Id(nent));
            if (root_P(blk))
              {
                nrent = createNewBlkEnt(seg);
                if (a2b(nrent))
                  {
                    reroot(blk, ent_Blk(nrent), ent_Id(nrent), seg_Bsiz(seg));
                    if ((nkeyEnt)==(ent))
                      {
                        nkeyEnt = nrent;
                        pkt_SetBlkToCache(pkt, ent_Id(nrent));
                      }
                  }
              }
            result_P = (true);
          }
        }
        if (result_P
            && index_P)
          {
            if (a2b(xent))
              {
                indexScrewCase = 1+(indexScrewCase);
                okeyEnt = xent;
                okeyPos = blkDataStart;
              }
            else if (!(split_P))
              okeyPos = nextCnvpair(blk, pkt_MatchPos(pkt));
            {
              byte []tmpstr = new byte[4];
              int oldvPos = (nextField(ent_Blk(okeyEnt), (okeyPos)+1))+1;
              int newvPos = (nextField(ent_Blk(nkeyEnt), (nkeyPos)+1))+1;
              subbytesMoveLeft(ent_Blk(okeyEnt), oldvPos, (oldvPos)+4, tmpstr, 0);
              subbytesMoveLeft(ent_Blk(nkeyEnt), newvPos, (newvPos)+4, ent_Blk(okeyEnt), oldvPos);
              subbytesMoveLeft(tmpstr, 0, 4, ent_Blk(nkeyEnt), newvPos);
            }
          }
        if (a2b(nrent))
          {
            ents_EntWrite(nrent);
            releaseEnt(nrent, accwrite);
          }
        if (a2b(nent))
          {
            ents_EntWrite(nent);
            ents_EntUpdateAccess_P(nent, accwrite, accnone);
          }
        if (result_P)
          {
            ent_SetDty(ent, true);
            if ((split_P
                || a2b(xent)
                || 0 != ((wcbSap)&(wcb))))
              ents_EntWrite(ent);
            releaseEnt(ent, accwrite);
          }
        if (a2b(xent))
          {
            ent_SetDty(xent, true);
            ents_EntWrite(xent);
            releaseEnt(xent, accwrite);
          }
        if (split_P)
          parentInsertUpdate(seg, rootId, blklev, splitStr, sLen, nId);
        if (a2b(nent))
          releaseEnt(nent, accnone);
        return result_P;
      }
    }
    
    /* This file was generated by scm2cs from source file "wbdefs.scm" */
    /*  "wbdefs.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */


    /*  FLC-LEN must be larger than 2 times the maximum number of blocks */
    /*  which would ever be needed for a freelist split. */

    public static readonly int flcLen = 0xa;
    
    /* amount to increase the ENT-TAB by when allocating buffers. */

    public static readonly int entTabInc = 0x200;
    
    /*  Byte-array directory names */
    /*  These should be protected against EBCDIC. */

    public static readonly byte []flcByts = stringToBytes("FLC");
    
    public static readonly byte []fldByts = stringToBytes("FLD");
    
    public static readonly byte []usedByts = stringToBytes("USED");
    
    public static readonly byte []bsizByts = stringToBytes("BSIZ");
    
    public static readonly byte []rootByts = stringToBytes("ROOT");
    
    public static readonly byte []clnByts = stringToBytes("CLN");
    
    public static readonly byte []authorsByts = stringToBytes("authors");
    
    public static readonly byte []noByts = stringToBytes("");
    

    public static bool err_P(int x)
    {
      return true
      && 0 > (x)
      && (x)>=(maxerr);
    }
    

    public static bool realerr_P(int x)
    {
      return true
      && (x)<=(retryerr)
      && (x)>=(maxerr);
    }
    

    public static bool success_P(int x)
    {
      return !(err_P(x));
    }
    
    /*  Return Codes */


    public static readonly int success = 0;
    
    /*  ERROR Return Codes */


    public static readonly int notpres =  -1;
    

    public static readonly int terminated =  -2;
    

    public static readonly int retryerr =  -10;
    

    public static readonly int keyerr =  -13;
    

    public static readonly int argerr =  -15;
    

    public static readonly int noroom =  -20;
    

    public static readonly int typerr =  -30;
    

    public static readonly int ioerr =  -40;
    

    public static readonly int strangerr =  -45;
    

    public static readonly int unkerr =  -90;
    

    public static readonly int maxerr =  -100;
    


    public static readonly int dirTyp = 0x44;
    
    public static readonly int indTyp = 0x54;
    
    public static readonly int seqTyp = 0x53;
    
    public static readonly int frlTyp = 0x46;
    

    public static readonly int wcbSap = 1;
    
    public static readonly int wcbSar = 2;
    
    public static readonly int wcbSac = 4;
    
    public static readonly int wcbFac = 8;
    

    public static readonly int endOfChain =  -1;
    
    public static readonly int startOfChain =  -2;
    

    public static readonly int leaf = 0x30;
    
    /*  BLK PREDICATES */


    public static bool root_P(byte []blk)
    {
      return (blk_Id(blk))==(blk_TopId(blk));
    }
    

    public static bool endOfChain_P(byte []blk)
    {
      return 0==(blk_NxtId(blk));
    }
    

    public static bool leaf_P(byte []blk)
    {
      return (blk_Level(blk))==(leaf);
    }
    

    public static int fieldLen(byte []blk,int pos)
    {
      return (blk[pos] & 0xFF);
    }
    

    public static void setFieldLen(byte []blk,int pos,int len)
    {
      blk[pos] = (byte) (0xff&(len));
      return;
    }
    
    /*  This is dangerous.  At the moment all occurences of next-field */
    /*  have simple expressions for the second argument. */


    public static int nextField(byte []blk,int pos)
    {
      return (fieldLen(blk, pos))+(pos)+1;
    }
    

    public static int nextCnvpair(byte []blk,int pos)
    {
      return nextField(blk, nextField(blk, 1+(pos)));
    }
    

    public static bool blkEmpty_P(byte []blk)
    {
      return (blk_End(blk))==(nextField(blk, 1+(blkDataStart)));
    }
    
    /*  LCK and ENT tables */

    /*  If you change this, then change amnesia-ent! */
    /*  This depends on segid never being less than -1 */

    public static int hash2int(int segid,int num)
    {
      return (((segid)*0x61)+(num)+((numBuks)*(1+(0x61/(numBuks)))))%(numBuks);
    }
    

    public static bool sameBuk_P(int aSegid,int aNum,int bSegid,int bNum)
    {
      return (hash2int(aSegid, aNum))==(hash2int(bSegid, bNum));
    }
    

    public static Ent getBuk(int segid,int blkNum)
    {
      return bukTab[hash2int(segid, blkNum)];
    }
    
    /*  doesnt wait, ie, returns #F if busy */

    public static bool getBukLck_P(int segid,int blkNum)
    {
      return tryLck_P(lckTab[hash2int(segid, blkNum)]);
    }
    

    public static Ent getBukWait(int segid,int blkNum)
    {
      lck(lckTab[hash2int(segid, blkNum)]);
      return bukTab[hash2int(segid, blkNum)];
    }
    

    public static void relBuk(int segid,int blkNum)
    {
      unlck(lckTab[hash2int(segid, blkNum)]);
      return;
    }
    
    /*  SET-BUK! assumes BUK is already lcked by caller */

    public static void setBuk(int segid,int blkNum,Ent ent)
    {
      bukTab[hash2int(segid, blkNum)] = ent;
      return;
    }
    
    /* (defconst ACCFOO 'ACCFOO) */

    public static readonly int accnone = 1;
    
    public static readonly int accread = 2;
    
    public static readonly int accwrite = 3;
    
    public static readonly int accpend = 4;
    
    /*  Tokens for use in the PKT:MATCH-POS field */

    public static readonly int pastp = 5;
    			    /* match(new-key, after-key) > repeatcount(after-key) */

    public static readonly int qpastp = 6;
    			    /* match(new-key, after-key) <= repeatcount(after-key) */

    public static readonly int match = 7;
    
    public static readonly int matchend = 8;
    
    public static readonly int pastend = 9;
    
    /*  Operation codes for SCAN */

    public static readonly int remScan =  -1;
    
    public static readonly int countScan = 0;
    
    public static readonly int modifyScan = 1;
    
    /* This file was generated by scm2cs from source file "prev.scm" */
    /*  "prev.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */




    public static Ent chainPrevFind(Ent ent,int accmode,byte []keyStr,int kLen,int []pkt,Ent prevEnt,int prevPos)
    {
    LchainPrevFind:while (true) {
      {
        byte []blk = ent_Blk(ent);
        blk_FindPos(blk, keyStr, kLen, pkt);
        if ((pkt_MatchType(pkt))==(pastend)
            && !(endOfChain_P(blk)))
          {
            int nxtNum = blk_NxtId(blk);
            wb.Seg seg = ent_Seg(ent);
            Ent nent = null;
            bool emptyBlk_P = (pkt_MatchPos(pkt))==(blkDataStart);
            int ppos = (emptyBlk_P
              ?prevPos
              :pkt_PrevMatchPos(pkt));
            if (emptyBlk_P)
              {
                releaseEnt(ent, accmode);
              }
            else {
              if (a2b(prevEnt))
                releaseEnt(prevEnt, accnone);
              ents_EntUpdateAccess_P(ent, accmode, accnone);
              prevEnt = ent;
            }
            nent = getEnt(seg, nxtNum, accmode);
            {
              ent = nent;
              prevPos = ppos;
              goto LchainPrevFind;
            }
          }
        else if ((pkt_MatchPos(pkt))==(blkDataStart))
          if (a2b(prevEnt))
            {
              releaseEnt(ent, accmode);
              ents_EntUpdateAccess_P(prevEnt, accnone, accmode);
              pkt_SetMatchType(pkt, match);
              pkt_SetMatchPos(pkt, prevPos);
              return prevEnt;
            }
          else {
            pkt_SetMatchType(pkt, pastend);
            pkt_SetMatchPos(pkt, 0);
            return ent;
          }
        else {
          if (a2b(prevEnt))
            releaseEnt(prevEnt, accnone);
          pkt_SetMatchType(pkt, match);
          pkt_SetMatchPos(pkt, pkt_PrevMatchPos(pkt));
          return ent;
        }
      }
    }
    }
    

    public static bool strGtr_P(byte []aStr,int aPos,int aLen,byte []bStr,int bPos,int bLen)
    {
      {
        int i = 0;
        int ap = aPos;
        int bp = bPos;
        Lloop: 
        if ((i)>=(aLen))
          return false;
        else if ((i)>=(bLen))
          return (true);
        else if (((aStr[ap] & 0xFF))<((bStr[bp] & 0xFF)))
          return false;
        else if (((bStr[bp] & 0xFF))<((aStr[ap] & 0xFF)))
          return (true);
        else {
          i = (i)+1;
          ap = (ap)+1;
          bp = (bp)+1;
          goto Lloop;
        }
      }
    }
    
    /*  PREV-KEY-ENT [was PREV-KEY] assumes entry with ACCNONE accmode to BLK. */
    /*  It either returns the  entry contining PREV(key) (with READ access) */
    /*  (and pos(prev) in PKT, type=MATCH) or #f, if there is no such key. */
    /*  call PREV-KEY-ENT with ROOT block... */

    /*  NOTE: PREV:PREV-K-ENT still needs the PENT kluge to keep the block */
    /*  unchanged while it works. */

    public static Ent prev_PrevKEnt(Ent ent,byte []keyStr,int kLen,int level,int []pkt)
    {
      if (a2b(ent))
        {
          Ent pent = getEnt(ent_Seg(ent), ent_Id(ent), accnone);
          ent = chainPrevFind(ent, accread, keyStr, kLen, pkt, null, 0);
          {
            Ent resEnt = ent;
            if ((pkt_MatchType(pkt))!=(match))
              {
                releaseEnt(ent, accread);
                resEnt = prev_PrevKEnt(prevBlkEnt(pent, level), keyStr, kLen, level, pkt);
              }
            releaseEnt(pent, accnone);
            return resEnt;
          }
        }
      else return null;
    }
    

    public static Ent prevKeyEnt(Ent ent,byte []keyStr,int kLen,int level,int []pkt)
    {
      if (a2b(ent))
        return prev_PrevKEnt(prev_FindPrevEnt(ent, level,  -1, keyStr, kLen), keyStr, kLen, level, pkt);
      else return null;
    }
    
    /*  CHAIN-TO-PREV-ENT: subroutine for PREV-BLK-ENT */
    /*  this routine chains fwd from FROM-ENT to imm predecessor of GOAL-BLK */
    /*  called with FROM-ENT open with ACCREAD; assumes GOAL-BLOCK-NO Name-locked */
    /*  returns an ENT open ACCREAD unless missed block, which returns #f */
    /*  (routine also checks if its past key) */


    public static Ent chainToPrevEnt(Ent fromEnt,int goalBlkNum,byte []goalKeyStr,int keyLen)
    {
    LchainToPrevEnt:while (true) {
      {
        byte []fromBlk = ent_Blk(fromEnt);
        if ((blk_NxtId(fromBlk))==(goalBlkNum))
          return fromEnt;
        else if (endOfChain_P(fromBlk))
          {
            Console.Error.Write(">>>>ERROR<<<< "+("chainToPrevEnt")+": hit end of "+(ent_Id(fromEnt))+":"+(goalBlkNum)+" lev="+(blk_Level(fromBlk))
   +" "+(keyLen)+"\n");
            return null;
          }
        else {
          int bPos = blkDataStart;
          if (strGtr_P(fromBlk, (bPos)+2, fieldLen(fromBlk, (bPos)+1), goalKeyStr, 0, keyLen))
            {
              Console.Error.Write(">>>>ERROR<<<< "+("chainToPrevEnt")+": missed blk "+(ent_Id(fromEnt))+":"+(goalBlkNum)+" lev="+(blk_Level(fromBlk))
   +" "+(keyLen)+"\n");
              return null;
            }
          else {
            fromEnt = switchEnt(fromEnt, accread, blk_NxtId(fromBlk), accread);
            goto LchainToPrevEnt;
          }
        }
      }
    }
    }
    
    /*  there must be a more efficient way to check this !!! */

    public static bool atRootLevel_P(wb.Seg seg,byte []blk)
    {
      if (root_P(blk))
        return (true);
      else {
        Ent rent = getEnt(seg, blk_TopId(blk), accread);
        byte []rblk = ent_Blk(rent);
        int rlevel = blk_Level(rblk);
        bool res_P = (blk_Level(blk))==(rlevel);
        releaseEnt(rent, accread);
        return res_P;
      }
    }
    
    /*  PREV-BLK-ENT [was PREV-BLK] is called with ENT (with ACCNONE accmode) */
    /*  which IS PRESERVED. IT finds the block that precedes ENT, or #f. */
    /*  It returns a (second) entry with READ access or #f. */
    /*  TBD - shouldn't it release ENT if returning #f? */
    /*  (no, not as things are now -- rjz) */

    public static Ent prevBlkEnt(Ent ent,int level)
    {
      ents_EntUpdateAccess_P(ent, accnone, accread);
      {
        byte []blk = ent_Blk(ent);
        ents_EntUpdateAccess_P(ent, accread, accnone);
        if (root_P(blk))
          return null;
        else {
          int skeyPos = splitKeyPos(blk);
          if (0 < (skeyPos))
            {
              int topNum = blk_TopId(blk);
              wb.Seg seg = ent_Seg(ent);
              int goalBlkNum = ent_Id(ent);
              byte []newStr = new byte[0x100];
              int kLen = reconThisKey(blk, skeyPos, newStr, 0, 0x100);
              if (atRootLevel_P(seg, blk))
                {
                  Console.Error.Write(""+("prevBlkEnt")+" code which has never been run!!\n");
                  return chainToPrevEnt(getEnt(seg, topNum, accread), goalBlkNum, newStr, kLen);
                }
              else {
                int []pkt = new int[pktSize];
                ent = prevKeyEnt(getEnt(seg, topNum, accnone), newStr, kLen, (level)+1, pkt);
                if ((ent)==null)
                  return null;
                else {
                  int nxtPos = nextField(ent_Blk(ent), 1+(pkt_MatchPos(pkt)));
                  int num = 0;
                  if ((nxtPos)==(blk_End(ent_Blk(ent))))
                    {
                      Console.Error.Write(""+("prevBlkEnt")+": I'm confused: at split key of blk "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+"");
                      num = (pkt_MatchPos(pkt))-4;
                    }
                  else num = 1+(nxtPos);
                  return chainToPrevEnt(switchEnt(ent, accread, str2long(ent_Blk(ent), num), accread), goalBlkNum, newStr, kLen);
                }
              }
            }
          else return null;
        }
      }
    }
    
    /*  FIND-PREV-ENT: called (like FIND-NEXT) with ACCNONE accmode on ENT. */
    /*  Returns a new ENT with ACCREAD accmode. Will always return an ENT */
    /*  unless some GET-ENT fails. */


    public static Ent prev_FindPrevEnt(Ent ent,int desiredLevel,int lastLevel,byte []keyStr,int kLen)
    {
    Lprev_FindPrevEnt:while (true) {
      if (a2b(ent))
        if (ents_EntUpdateAccess_P(ent, accnone, accread))
          {
            byte []blk = ent_Blk(ent);
            if ((blk_Level(blk))==(desiredLevel))
              return ent;
            else if ((blk_Level(blk))<(desiredLevel))
              {
                Console.Error.Write(">>>>ERROR<<<< "+("findPrevEnt")+": bad blk level\n");
                return null;
              }
            else if ((lastLevel)>=0
                && (blk_Level(blk))!=((lastLevel)-1))
              {
                Console.Error.Write(">>>>ERROR<<<< "+("findPrevEnt")+": bad blk level "+(blk_Level(blk))+" last="+(lastLevel)+" in "+(seg_Id(ent_Seg(ent)))
   +":"+(ent_Id(ent))+"\n");
                return null;
              }
            else {
              int []pkt = new int[pktSize];
              ent = chainFind(ent, accread, keyStr, kLen, pkt);
              if (a2b(ent))
                {
                  int nxtPos = nextField(ent_Blk(ent), 1+(pkt_MatchPos(pkt)));
                  int ptrPos = ((nxtPos)==(blk_End(ent_Blk(ent)))
                    ?(pkt_MatchPos(pkt))-4
                    :1+(nxtPos));
                  {
                    Ent T_ent = switchEnt(ent, accread, str2long(ent_Blk(ent), ptrPos), accnone);
                    lastLevel = blk_Level(ent_Blk(ent));
                    ent = T_ent;
                    goto Lprev_FindPrevEnt;
                  }
                }
              else return null;
            }
          }
        else return null;
      else return null;
    }
    }
    
    /* This file was generated by scm2cs from source file "del.scm" */
    /*  "del.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */




    public static bool del_DeferBlockDeletes_P = false;
    
    /*  fixes: */
    /*  1. 1/22 blk-delete should not be called if END-OF-CHAIN */
    /*  2.      IND-REM-V&K needed to return B-POS */
    /*  3.      CHAIN-KEY-REM also neede to check for being already at root level */
    /*  4. 1/23 fixed BLK-DELETE? to set accmode to ACCNONE while calling PREV-BLK-ENT! */
    /*  5.      fixed CHAIN-KEY-REM to give error message if key not found in index */

    /*  BLK-DELETE assumes caller has ACCWRITE to blk and will */
    /*  release if after blk-delete returns */

    /*  sorry, waiting on parent-update is losing since */
    /*  deletes that  lock the entire path to the root will almost certainly */
    /*  NEVER succeed! */


    public static bool del_DeleteBck(Ent ent)
    {
      byte []blk = ent_Blk(ent);
      bool win_P = !(del_DeferBlockDeletes_P);
      if (win_P)
        {
          ents_EntUpdateAccess_P(ent, accwrite, accnone);
          {
            Ent prent = prevBlkEnt(ent, blk_Level(blk));
            win_P = ents_EntUpdateAccess_P(ent, accnone, accwrite);
            if (win_P
                && a2b(prent))
              {
                win_P = ents_EntUpdateAccess_P(prent, accread, accwrite);
              }
            else ;
            win_P = win_P
            && 1==(ent_Ref(ent));
            if (win_P)
              {
                if (!(atRootLevel_P(ent_Seg(ent), blk)))
                  {
                    int skeyPos = splitKeyPos(blk);
                    if (0 < (skeyPos))
                      {
                        int topNum = blk_TopId(blk);
                        wb.Seg seg = ent_Seg(ent);
                        int level = blk_Level(blk);
                        byte []keyStr = new byte[0x100];
                        int kLen = reconThisKey(blk, skeyPos, keyStr, 0, 0x100);
                        win_P = parentDeleteUpdate_P(seg, topNum, level, ent_Id(ent), keyStr, kLen);
                      }
                    else ;
                  }
                win_P = win_P
                && 1==(ent_Ref(ent));
                if (win_P)
                  {
                    if (a2b(prent))
                      {
                        blk_SetNxtId(ent_Blk(prent), blk_NxtId(blk));
                        ent_SetDty(prent, true);
                        ents_EntWrite(prent);
                      }
                    win_P = blkFree(ent);
                    if (!(win_P))
                      Console.Error.Write(">>>>ERROR<<<< "+("blkDelete")+": could not free "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+"\n");
                  }
              }
            if (a2b(prent))
              releaseEnt(prent, ent_Acc(prent));
          }
        }
      if (win_P)
        {
          blockDeletes = (blockDeletes)+1;
        }
      else {
        deferredDeletes = 1+(deferredDeletes);
        Console.Error.Write("Can't delete block "+(ent_Id(ent))+"\n");
      }
      return win_P;
    }
    
    /*  return #t if operation was succsessful; #f if not */
    /*  Note the deletion of blk OLD-ID by removing its KEY+ID from parent. */
    /*  Note this routine does not check if the key has already been */
    /*  (perhaps by another process) deleted from the parent. */


    public static bool parentDeleteUpdate_P(wb.Seg seg,int topId,int level,int oldId,byte []keyStr,int kLen)
    {
      int []pkt = new int[pktSize];
      int ans =  -1;
      byte []ansStr = new byte[4];
      {
        Ent ent = findEnt(getEnt(seg, topId, accnone), 1+(level),  -1, keyStr, kLen);
        if (!(a2b(ent)))
          ;
        else if (ents_EntUpdateAccess_P(ent, accread, accwrite))
          {
            ent = chainFind(ent, accwrite, keyStr, kLen, pkt);
          }
        else {
          releaseEnt(ent, accread);
          ent = null;
        }
        if (a2b(ent))
          {
            ans = del_ChainRem(ent, keyStr, kLen, ansStr, pkt, wcbSar);
            if ((ans)>=0)
              if ((oldId)!=(str2long(ansStr, 0)))
                Console.Error.Write(">>>>ERROR<<<< "+("parentDeleteUpdate_P")+": bad value "+(str2long(ansStr, 0))+" in deleted down pointer "+(oldId)+" told\n");
            releaseEnt(ent, accwrite);
          }
        if ((a2b(ent)
            || (ans)>=0))
          return (true);
        else {
          Console.Error.Write("WARNING: "+("parentDeleteUpdate_P")+" blk="+(seg_Id(seg))+":"+(oldId)+", level="+(level)
   +", key="+(kLen)+"\n");
          return false;
        }
      }
    }
    
    /*  called with ACCREAD on ENT, releases ent before returning */
    /*  DEL:CHAIN-REM can call BLK-DELETE */
    /*    BLK-DELETE calls BLK-FREE */
    /*      BLK-FREE calls AMNESIA-ENT! which sets the segment number to -1 */
    /*  DEL:CHAIN-REM calls RELEASE-ENT! */
    /*  Chad Gadya! */


    public static int del_ChainRem(Ent ent,byte []keyStr,int kLen,byte []ansStr,int []pkt,int wcb)
    {
      if ((pkt_MatchType(pkt))==(match))
        {
          int alen = success;
          if (a2b(ansStr))
            alen = getThisVal(ent_Blk(ent), pkt_MatchPos(pkt), ansStr);
          blk_RemoveKeyAndVal(ent_Blk(ent), pkt_MatchPos(pkt), seg_Bsiz(ent_Seg(ent)));
          ent_SetDty(ent, true);
          if (blkEmpty_P(ent_Blk(ent))
              && !(endOfChain_P(ent_Blk(ent))))
            {
              del_DeleteBck(ent);
            }
          else if ((0 != ((wcbSar)&(wcb))
              || (blk_Level(ent_Blk(ent)))>(leaf)))
            ents_EntWrite(ent);
          return alen;
        }
      else return notpres;
    }
    
    /* This file was generated by scm2cs from source file "ents.scm" */
    /*  "ents.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000, 2003, 2006 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */



    /*  tables */


    public static Lck []lckTab = null;
    
    public static Ent []bukTab = null;
    
    public static Ent []entTab = null;
    
    public static int numEntsCt = 0;
    
    public static int numBuks = 0;
    
    public static int blkSize = 0;
    

    public static bool cacheEntEnable_P = (true);
    
    /*  DATABASE LEVEL OPERATIONS */

    /*  This can be bummed to write less than the full BSIZ if we know */
    /*  what the disk sector size is. */
    /*  fixed order check in ent-write */


    public static bool ents_EntWrite(Ent ent)
    {
      wb.Seg seg = ent_Seg(ent);
      byte []blk = ent_Blk(ent);
      if (!(blk_Typ_P(blk, seqTyp)))
        checkKeyOrder(blk);
      blk_SetTime(blk, (int)(DateTime.Now.Ticks/10000000L));
      if (!(seg_Mutable_P(seg)))
        {
          Console.Error.Write(">>>>ERROR<<<< "+("entWrite")+" on read only segment "+(seg_Id(seg))+"?\n");
          return false;
        }
      else if (a2b(blkio_Write(seg_Port(seg), blk, seg_Bsiz(seg), ent_Id(ent))))
        {
          ent_SetDty(ent, null);
          return (true);
        }
      else {
        ent_SetDty(ent, true);
        return false;
      }
    }
    
    /*  FLUSHING needs to be proportional to time (to put some limit on */
    /*  how long things are left unwritten) plus write-activity. */

    /*  NOTE: While flushing a buffer, get ACCPEND accmode to it (to */
    /*  prevent surprise mods) */


    public static int flushEntCntr = 0;
    
    public static Lck flushEntLck = makeLck( -2);
    

    public static int entsFlush(int trynum,int flushnum)
    {
      int flushednum = 0;
      if (a2b(flushEntLck)
          && tryLck_P(flushEntLck))
        {
          int iCt = trynum;
          while (!((0==(iCt)
                   || (flushednum)>=(flushnum)))) {
            flushEntCntr = (1+(flushEntCntr))%(numEntsCt);
            {
              Ent tent = entTab[flushEntCntr];
              if (ent_Dty_P(tent)
                  && !(a2b(ent_Acc(tent)))
                  && entFlush_P(tent))
                {
                  showBuffer1(tent);
                  flushednum = (flushednum)+1;
                }
            }
            {
              iCt = (iCt)-1;
            }
          }
          unlck(flushEntLck);
          return flushednum;
        }
      else return 0;
    }
    

    public static bool entFlush_P(Ent tent)
    {
      wb.Seg eSeg = ent_Seg(tent);
      int eId = ent_Id(tent);
      getBukLck_P(seg_Id(eSeg), eId);
      {
        Ent ent = getBuk(seg_Id(eSeg), eId);
        Lloop: 
        if (!(a2b(ent)))
          {
            relBuk(seg_Id(eSeg), eId);
            return false;
          }
        else if ((tent)!=(ent))
          {
            ent = ent_Next(ent);
            goto Lloop;
          }
        else if (!(ent_Dty_P(ent)
                && (accnone)==(ent_Acc(ent))))
          {
            relBuk(seg_Id(eSeg), eId);
            return false;
          }
        else {
          ent_SetAcc(ent, accpend);
          relBuk(seg_Id(eSeg), eId);
          ents_EntWrite(ent);
          getBukWait(seg_Id(eSeg), eId);
          ent_SetAcc(ent, accnone);
          relBuk(seg_Id(eSeg), eId);
          flushCt = (flushCt)+1;
          return (true);
        }
      }
    }
    
    /*  release-ent! gives up all claim to ent, which is expected to be of */
    /*  type accmode */
    /*  fixed warning about dirty dirs -- twice */
    /*  fixed dirty-block writer in UPDATE-ACCESS! */


    public static void releaseEnt(Ent ent,int accmode)
    {
      int blknum = ent_Id(ent);
      wb.Seg seg = ent_Seg(ent);
      Ent buk = null;
      buk = getBukWait(seg_Id(seg), blknum);
      if ((accnone)!=(accmode)
          && (ent_Acc(ent))!=(accmode))
        Console.Error.Write(">>>>ERROR<<<< "+("releaseEnt")+": unexpected accmode of "+(seg_Id(seg))+":"+(blknum)+" is "+(ent_Acc(ent))
   +" not "+(accmode)+"\n");
      if ((accnone)==(accmode))
        ;
      else if (!(ent_Dty_P(ent)))
        ;
      else if (blk_Typ_P(ent_Blk(ent), dirTyp)
          && leaf_P(ent_Blk(ent)))
        {
          Console.Error.Write("WARNING: Directory block "+(seg_Id(seg))+":"+(blknum)+" dirty at RELEASE-ENT! \n");
          dirDtyCt = 1+(dirDtyCt);
        }
      else if (blk_Typ_P(ent_Blk(ent), seqTyp))
        {
          relBuk(seg_Id(seg), blknum);
          ents_EntWrite(ent);
          buk = getBukWait(seg_Id(seg), blknum);
        }
      if ((accnone)!=(accmode))
        ent_SetAcc(ent, accnone);
      if ((ent_Ref(ent))<=0)
        {
          ent_SetRef(ent, 0);
          Console.Error.Write(">>>>ERROR<<<< REF count below 0 in "+(seg_Id(seg))+":"+(blknum)+"\n");
        }
      else ent_SetRef(ent, (ent_Ref(ent))-1);
      if (!(a2b(seg)))
        {
          spliceOutEnt(seg, blknum, buk, ent);
        }
      else ent_SetAge(ent, ((ent_Dty_P(ent)
           ?5
           :0))+(5*(6+((leaf)-(blk_Level(ent_Blk(ent)))))));
      relBuk(seg_Id(seg), blknum);
      return;
    }
    

    public static bool ents_EntUpdateAccess_P(Ent ent,int oldAccmode,int newAccmode)
    {
      getBukWait(seg_Id(ent_Seg(ent)), ent_Id(ent));
      if ((ent_Acc(ent))!=(oldAccmode))
        {
          relBuk(seg_Id(ent_Seg(ent)), ent_Id(ent));
          Console.Error.Write(">>>>ERROR<<<< unexpected accmode type on "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+" "+(ent_Acc(ent))+" (expected "+(oldAccmode)
   +")\n");
        }
      if ((accnone)==(oldAccmode))
        ;
      else if (!(ent_Dty_P(ent)))
        ;
      else if (blk_Typ_P(ent_Blk(ent), seqTyp))
        {
          relBuk(seg_Id(ent_Seg(ent)), ent_Id(ent));
          ents_EntWrite(ent);
          getBukWait(seg_Id(ent_Seg(ent)), ent_Id(ent));
        }
      else if (blk_Typ_P(ent_Blk(ent), dirTyp)
          && leaf_P(ent_Blk(ent)))
        {
          Console.Error.Write("WARNING: Directory block "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+" dirty at ENT-UPD-ACCESS! \n");
          dirDtyCt = 1+(dirDtyCt);
        }
      ent_SetAcc(ent, newAccmode);
      relBuk(seg_Id(ent_Seg(ent)), ent_Id(ent));
      return a2b(ent)
      && (true);
    }
    
    /*  ENT-FREE-LIST stuff ----------------------------------------------------------- */


    public static int freeBukCntr = 0;
    
    public static Ent freeEnts = null;
    
    public static Lck freeEntLck = makeLck( -1);
    

    public static Ent getFreeFreeEnt()
    {
      lck(freeEntLck);
      if (a2b(freeEnts))
        {
          Ent freeEnt = freeEnts;
          freeEnts = ent_Next(freeEnts);
          unlck(freeEntLck);
          return freeEnt;
        }
      else return null;
    }
    
    /*  this version assumes the caller has already locked the bucket */
    /*  BUK containing ENT */


    public static void spliceOutEnt(wb.Seg seg,int blkNum,Ent buk,Ent ent)
    {
      {
        Ent bent = buk;
        Ent lastent = null;
        while (!((!(a2b(bent))
                 || (bent)==(ent)))) {
          {
            Ent T_bent = ent_Next(bent);
            lastent = bent;
            bent = T_bent;
          }
        }
        if (a2b(bent))
          {
            if (a2b(lastent))
              {
                ent_SetNext(lastent, ent_Next(bent));
              }
            else setBuk(seg_Id(seg), blkNum, ent_Next(bent));
            recycleEnt(bent);
            return;
          }
        else Console.Error.Write("WARNING: "+("spliceOutEnt")+" couldn't "+(seg_Id(seg))+":"+(blkNum)+"\n");
        return;
      }
    }
    

    public static void recycleEnt(Ent ent)
    {
      ent_SetDty(ent, null);
      ent_SetPus(ent, 0);
      ent_SetSeg(ent, null);
      ent_SetId(ent, 0);
      lck(freeEntLck);
      ent_SetRef(ent, 0);
      ent_SetAcc(ent, accnone);
      ent_SetNext(ent, freeEnts);
      freeEnts = ent;
      unlck(freeEntLck);
      return;
    }
    
    /*  SELECT-IDLE-ENT selects a candidate entry for reuse.  caller needs to call */
    /*  RECLAIM-ENT next to splice entry out of its bucket. */
    /*  NOTE: when called, bucket (lseg lblk-num) is lcked. */
    /*  The target bucket is assumed unlocked if lseg < 0. */
    /*  (GET-ENT calls this with the bucket locked to prevent someone else from */
    /*  getting another entry for the same block.) */


    public static Ent selectIdleEnt(wb.Seg lseg,int lblkNum)
    {
      {
        Ent oldestEnt = null;
        int numScan = Math.Max(Math.Min(numBuks, 0xa), (numBuks)/0x14);
        int freeBase = freeBukCntr;
        freeBukCntr = ((numScan)+(freeBukCntr))%(numBuks);
        unlck(freeEntLck);
        {
          int i = 0;
          while (!(((i)>(numScan)
                       && a2b(oldestEnt)
                   || (i)>(numBuks)))) {
            {
              int freeNum = ((freeBase)+(i))%(numBuks);
              bool dontLock_P = (!(a2b(lseg))
                ?false
                :(freeNum)==(hash2int(seg_Id(lseg), lblkNum)));
              if ((dontLock_P
                      || getBukLck_P(0, freeNum)))
                {
                  Ent ent = getBuk(0, freeNum);
                  while (a2b(ent)) {
                    if (0==(ent_Ref(ent)))
                      {
                        ent_SetAge(ent, ((ent_Dty_P(ent)
                             ?1
                             :2))+(ent_Age(ent)));
                        if ((accnone)==(ent_Acc(ent))
                            && (!(a2b(oldestEnt))
	   || (ent_Age(ent))>(ent_Age(oldestEnt))))
                          {
                            oldestEnt = ent;
                          }
                        else ;
                      }
                    {
                      ent = ent_Next(ent);
                    }
                  }
                  if (dontLock_P)
                    ;
                  else relBuk(0, freeNum);
                }
              else ;
            }
            {
              i = (i)+1;
            }
          }
          if ((i)>(numBuks))
            Console.Error.Write(">>>>ERROR<<<< No free ents\n");
          return oldestEnt;
        }
      }
    }
    
    /*  RECLAIM-ENT unlinks ENT from its bucket if its not in use. */
    /*  It writes out the entry-s block if it's dirty */
    /*  RECLAIM-ENT has 3 cases */
    /*   (a) ENT is in use -- LSEG is unlocked, NIL is returned */
    /*   (b) ENT is clean -- ENT is unlinked and returned */
    /*   (c) ENT is DIRTY -- ENT is written, unlinked, and reclaimed (put on */
    /*             free lsit); LSEG is UNLOCKED, NIL is returned. */
    /*     possible optimization in case (c): if LSEG = -, */
    /*     ENT could be written, unlinked, and returned (like (b)) */


    public static Ent reclaimEnt(Ent ent,wb.Seg lseg,int lblkNum)
    {
      {
        wb.Seg seg = ent_Seg(ent);
        int blkNum = ent_Id(ent);
        bool segsEqual_P = a2b(lseg)
        && sameBuk_P(seg_Id(lseg), lblkNum, seg_Id(seg), blkNum);
        Ent buk = (segsEqual_P
          ?getBuk(seg_Id(seg), blkNum)
          :getBukWait(seg_Id(seg), blkNum));
        if ((!(0==(ent_Ref(ent)))
            || (accnone)!=(ent_Acc(ent))))
          {
            relBuk(seg_Id(seg), blkNum);
            if (segsEqual_P)
              ;
            else if (!(a2b(lseg)))
              ;
            else relBuk(seg_Id(lseg), lblkNum);
            Console.Error.Write("WARNING: "+("reclaimEnt")+": couldn't splice-out-ent "+(seg_Id(lseg))+":"+(lblkNum)+"\n");
            return null;
          }
        else {
          Ent bent = buk;
          Ent lastent = null;
          while (!((!(a2b(bent))
                   || (ent)==(bent)))) {
            {
              Ent T_bent = ent_Next(bent);
              lastent = bent;
              bent = T_bent;
            }
          }
          if (!(a2b(bent)))
            {
              relBuk(seg_Id(seg), blkNum);
              if (segsEqual_P)
                ;
              else if (!(a2b(lseg)))
                ;
              else relBuk(seg_Id(lseg), lblkNum);
              Console.Error.Write(">>>>ERROR<<<< "+("reclaimEnt")+": couldn't find ent in bucket "+(seg_Id(seg))+":"+(blkNum)+" l="+(seg_Id(lseg))
   +":"+(lblkNum)+"\n");
              return null;
            }
          else if (!(ent_Dty_P(ent)))
            {
              if (a2b(lastent))
                {
                  ent_SetNext(lastent, ent_Next(ent));
                }
              else setBuk(seg_Id(seg), blkNum, ent_Next(ent));
              ent_SetNext(ent, null);
              if (segsEqual_P)
                ;
              else relBuk(seg_Id(seg), blkNum);
              return ent;
            }
          else {
            ent_SetAcc(ent, accpend);
            relBuk(seg_Id(seg), blkNum);
            if (segsEqual_P)
              ;
            else if (!(a2b(lseg)))
              ;
            else relBuk(seg_Id(lseg), lblkNum);
            ents_EntWrite(ent);
            buk = getBukWait(seg_Id(seg), blkNum);
            ent_SetAcc(ent, accnone);
            spliceOutEnt(seg, blkNum, buk, ent);
            relBuk(seg_Id(seg), blkNum);
            return null;
          }
        }
      }
    }
    
    /*  TRY-GET-FREE-ENT either returns a free ent OR unlocks (lseg lblk-num) */


    public static Ent tryGetFreeEnt(wb.Seg lseg,int lblkNum)
    {
      Ent ent = getFreeFreeEnt();
      if (!(a2b(ent)))
        {
          ent = selectIdleEnt(lseg, lblkNum);
          if (a2b(ent))
            {
              ent = reclaimEnt(ent, lseg, lblkNum);
            }
          else if (!(a2b(lseg)))
            ;
          else relBuk(seg_Id(lseg), lblkNum);
        }
      return ent;
    }
    

    /*  Special entry points for Jonathan to do non-B-tree stuff. */
    /*  Also now used in chain-scan. */


    public static Ent allocateEnt()
    {
      {
        Ent ent = tryGetFreeEnt(null,  -1);
        int cnt = 0x13;
        Lloop: 
        if (a2b(ent))
          {
            ent_SetAcc(ent, accwrite);
            ent_SetDty(ent, true);
            ent_SetPus(ent, 0);
            ent_SetSeg(ent, null);
            ent_SetId(ent, 0);
            ent_SetRef(ent, 1);
            ent_SetNext(ent, null);
            return ent;
          }
        else if (0==(cnt))
          return null;
        else {
          ent = tryGetFreeEnt(null,  -1);
          cnt =  -1+(cnt);
          goto Lloop;
        }
      }
    }
    

    public static void entCopy(Ent toEnt,Ent fromEnt)
    {
      if ((ent_Acc(toEnt))!=(accwrite))
        Console.Error.Write(">>>>ERROR<<<< "+("entCopy")+": copying into non-ACCWRITE "+(seg_Id(ent_Seg(toEnt)))+":"+(ent_Id(toEnt))+"\n");
      ent_SetSeg(toEnt, ent_Seg(fromEnt));
      ent_SetId(toEnt, ent_Id(fromEnt));
      subbytesMove(ent_Blk(fromEnt), 0, seg_Bsiz(ent_Seg(fromEnt)), ent_Blk(toEnt), 0);
      return;
    }
    

    public static bool getEntCopy(Ent toEnt,wb.Seg seg,int blkNum)
    {
      Ent fromEnt = getEnt(seg, blkNum, accread);
      if (a2b(fromEnt))
        {
          entCopy(toEnt, fromEnt);
          releaseEnt(fromEnt, accread);
          return (true);
        }
      else return false;
    }
    

    public static void flushFlc(wb.Seg seg,int fullness)
    {
    LflushFlc:while (true) {
      {
        byte []fstr = new byte[4];
        byte []tstr = new byte[4];
        lck(seg_Lck(seg));
        if ((seg_FlcLen(seg))<=(fullness))
          {
            unlck(seg_Lck(seg));
            return;
          }
        else if ((true))
          {
            long2str(fstr, 0, seg_Flc(seg)[(seg_FlcLen(seg))-1]);
            seg_SetFlcLen(seg, (seg_FlcLen(seg))-1);
            unlck(seg_Lck(seg));
            long2str(tstr, 0, (int)(DateTime.Now.Ticks/10000000L));
            btPut(seg_FlHan(seg), fstr, 4, tstr, 4);
            goto LflushFlc;
          }
      }
      return;
    }
    }
    
    /*  Assumes that SEG-LCK is locked by this process */


    public static bool initloadFlc_P(wb.Seg seg)
    {
      {
        int caseVal6 = seg_FlcLen(seg);
        if (( -1 == caseVal6)){
          {
            byte []tmpStr = new byte[0x14];
            int flcImageLen = btGet(seg_RtHan(seg), flcByts, 3, tmpStr);
            if (0 > (flcImageLen))
              flcImageLen = 0;
            btPut(seg_RtHan(seg), flcByts, 3, noByts, 0);
            seg_SetFlcLen(seg, (flcImageLen)/4);
            {
              int i =  -4+(flcImageLen);
              while (!(0 > (i))) {
                seg_Flc(seg)[(i)/4] = str2long(tmpStr, i);
                {
                  i =  -4+(i);
                }
              }
            }
          }
          return (true);
        }
        else if (( -2 == caseVal6)){
          Console.Error.Write(">>>>ERROR<<<< "+("initloadFlc")+" on read only segment "+(seg_Id(seg))+"?\n");
          return false;
        }
      else {
          return (true);
        }
      }
    }
    
    /*  Called with SEG-LCK locked. */
    /*  If you don't know what you are doing. DON'T DO IT! */
    /*  Compute inverse hash function so that ent can still be found. */

    public static void amnesiaEnt(Ent ent)
    {
      int segid = seg_Id(ent_Seg(ent));
      {
        int hash = hash2int(segid, ent_Id(ent));
        int newid = hash2int(1+(segid), ent_Id(ent));
        ent_SetId(ent, newid);
        ent_SetSeg(ent, null);
        if ((hash)!=(hash2int( -1, newid)))
          Console.Error.Write("WARNING: "+("amnesiaEnt")+": hash mismatch "+(hash)+" >< "+(hash2int( -1, newid))+"\n");
        ent_SetDty(ent, null);
        ent_SetPus(ent, 0);
        if (a2b(ent_Blk(ent)))
          if (blk_Typ_P(ent_Blk(ent), dirTyp))
            blk_SetTyp(ent_Blk(ent), indTyp);
        ent_SetAge(ent, 0x80);
        return;
      }
    }
    

    public static bool blkFree(Ent ent)
    {
    LblkFree:while (true) {
      {
        wb.Seg seg = ent_Seg(ent);
        if ((ent_Acc(ent))!=(accwrite))
          {
            Console.Error.Write(">>>>ERROR<<<< "+("blkFree")+": "+(seg_Id(seg))+":"+(ent_Id(ent))+" without ACCWRITE\n");
            return false;
          }
        else {
          lck(seg_Lck(seg));
          if (!(initloadFlc_P(seg)))
            {
              unlck(seg_Lck(seg));
              return false;
            }
          else if ((seg_FlcLen(seg))>=((flcLen)-1))
            {
              unlck(seg_Lck(seg));
              flushFlc(seg, (flcLen)-2);
              goto LblkFree;
            }
          else {
            seg_Flc(seg)[seg_FlcLen(seg)] = ent_Id(ent);
            seg_SetFlcLen(seg, (seg_FlcLen(seg))+1);
            amnesiaEnt(ent);
            unlck(seg_Lck(seg));
            return (true);
          }
        }
      }
    }
    }
    

    public static int flcFill(wb.Seg seg)
    {
      byte []fstr = new byte[4];
      int flen = 0;
      int status;
      lck(seg_Lck(seg));
      if ((seg_FlcLen(seg))>=1)
        {
          unlck(seg_Lck(seg));
          return success;
        }
      else if (!(tryLck_P(seg_Fck(seg))))
        {
          unlck(seg_Lck(seg));
          Console.Error.Write("WARNING: "+("flcFill")+" failed -- branch never tried before! Segment "+(seg_Id(seg))+" "+(seg_Str(seg))+"\n");
          return retryerr;
        }
      else 
      flen = btNext(seg_FlHan(seg), noByts, 0, fstr);
      if (err_P(flen))
        {
          int xnum = (seg_Used(seg))+((flcLen)/2);
          if (a2b(blkio_FileExtend(seg_Port(seg), seg_Bsiz(seg), xnum)))
            {
              {
                int i = 0;
                while (!((i)>((flcLen)/2))) {
                  seg_Flc(seg)[seg_FlcLen(seg)] = (xnum)-(i);
                  seg_SetFlcLen(seg, (seg_FlcLen(seg))+1);
                  seg_SetUsed(seg, (seg_Used(seg))+1);
                  {
                    i = (i)+1;
                  }
                }
              }
              {
                byte []usedStr = new byte[4];
                long2str(usedStr, 0, seg_Used(seg));
                btPut(seg_RtHan(seg), usedByts, 4, usedStr, 4);
              }
              {
                status = success;
                goto LunlckAndReturn;
              }
            }
          else {
            Console.Error.Write(">>>>ERROR<<<< No more file space available! Segment "+(seg_Id(seg))+" "+(seg_Str(seg))+"\n");
            {
              status = noroom;
              goto LunlckAndReturn;
            }
          }
        }
      else {
        unlck(seg_Lck(seg));
        {
          int []longAra = new int[(flcLen)+1];
          byte []xstr = new byte[0x100];
          int []respkt = new int[pktSize];
          int result = success;
          subbytesMove(fstr, 0, flen, xstr, 0);
          longAra[0] = 0;
          pkt_SetSkeyCount(respkt, 0);
          result = btScan(seg_FlHan(seg), remScan, xstr, flen, noByts, endOfChain, "flcProc", longAra, respkt, 1);
          if (((result)==(success)
              || (result)==(notpres)
              || (result)==(terminated)))
            {
              lck(seg_Lck(seg));
              {
                int i = longAra[0];
                while (!((i)<=0)) {
                  seg_Flc(seg)[seg_FlcLen(seg)] = longAra[i];
                  seg_SetFlcLen(seg, (seg_FlcLen(seg))+1);
                  {
                    i = (i)-1;
                  }
                }
              }
              {
                status = success;
                goto LunlckAndReturn;
              }
            }
          else {
            unlck(seg_Fck(seg));
            return result;
          }
        }
      }
LunlckAndReturn:
      unlck(seg_Lck(seg));
      unlck(seg_Fck(seg));
      return status;
    }
    

    public static int flcProc(byte []keystr,int klen,byte []vstr,int vlen,int []longAra)
    {
      {
        int ct = longAra[0];
        if ((ct)<((flcLen)/2))
          {
            int num = str2long(keystr, 0);
            ct = (ct)+1;
            longAra[0] = ct;
            longAra[ct] = num;
            return success;
          }
        else return terminated;
      }
    }
    
    /*  create-new-blk-ent leaves you with ACCWRITE accmode to blk */

    public static Ent createNewBlkEnt(wb.Seg seg)
    {
    LcreateNewBlkEnt:while (true) {
      lck(seg_Lck(seg));
      if (!(initloadFlc_P(seg)))
        {
          unlck(seg_Lck(seg));
          return null;
        }
      else if ((seg_FlcLen(seg))<=0)
        {
          unlck(seg_Lck(seg));
          if (!(realerr_P(flcFill(seg))))
            goto LcreateNewBlkEnt;
          else return null;
        }
      else {
        seg_SetFlcLen(seg, (seg_FlcLen(seg))-1);
        {
          int bnum = seg_Flc(seg)[seg_FlcLen(seg)];
          unlck(seg_Lck(seg));
          {
            Ent ent = getEnt(seg, bnum, accwrite);
            if (a2b(ent))
              ent_SetDty(ent, true);
            return ent;
          }
        }
      }
    }
    }
    
    /*  End of stuff to deal with the free-list-cache (FLC) */

    /*  try-get-ent returns an entry with accmode or #f if blk is lcked. */
    /*  When you are done with the entry you need to release-ent!. */

    public static Ent tryGetEnt(wb.Seg seg,int blkNum,int accmode)
    {
      {
        Ent buk = getBukWait(seg_Id(seg), blkNum);
        {
          Ent ent = buk;
          Lentloop: 
          if (!(a2b(ent)))
            {
              relBuk(seg_Id(seg), blkNum);
              tgeFct = 1+(tgeFct);
              return null;
            }
          else if (!((seg)==(ent_Seg(ent))
                  && (blkNum)==(ent_Id(ent))))
            {
              ent = ent_Next(ent);
              goto Lentloop;
            }
          else if ((blk_Id(ent_Blk(ent)))!=(blkNum))
            {
              relBuk(seg_Id(seg), blkNum);
              Console.Error.Write(">>>>ERROR<<<< corrutped buffer "+(seg_Id(ent_Seg(ent)))+":"+(blk_Id(ent_Blk(ent)))+" <> "+(blkNum)+"\n");
              tgeFct = 1+(tgeFct);
              return null;
            }
          else if ((accnone)==(accmode))
            {
              ent_SetRef(ent, 1+(ent_Ref(ent)));
              relBuk(seg_Id(seg), blkNum);
              tgeCt = 1+(tgeCt);
              return ent;
            }
          else if ((accnone)==(ent_Acc(ent)))
            {
              ent_SetAcc(ent, accmode);
              ent_SetRef(ent, 1+(ent_Ref(ent)));
              relBuk(seg_Id(seg), blkNum);
              tgeCt = 1+(tgeCt);
              return ent;
            }
          else {
            relBuk(seg_Id(seg), blkNum);
            tgeFct = 1+(tgeFct);
            return null;
          }
        }
      }
    }
    

    public static Ent chainFindEnt(wb.Han han,int accmode,byte []keyStr,int kLen,int []pkt)
    {
      Ent ent = (cacheEntEnable_P
          && a2b(han_Last(han))
        ?tryGetEnt(han_Seg(han), han_Last(han), accmode)
        :null);
      if (a2b(ent)
          && leaf_P(ent_Blk(ent))
          && (blk_TopId(ent_Blk(ent)))==(han_Id(han))
          && a2b(blk_FindPos(ent_Blk(ent), keyStr, kLen, pkt))
          && ((pkt_MatchType(pkt))==(match)
                 || ((pkt_MatchType(pkt))==(pastp)
                            || (pkt_MatchType(pkt))==(qpastp))
                        && (pkt_MatchPos(pkt))>(blkDataStart)))
        {
          tceCt = (tceCt)+1;
          return ent;
        }
      else {
        if (a2b(ent))
          releaseEnt(ent, accmode);
        tceFct = (tceFct)+1;
        ent = getEnt(han_Seg(han), han_Id(han), accnone);
        if ((!(root_P(ent_Blk(ent)))
            || blk_Typ_P(ent_Blk(ent), seqTyp)))
          {
            Console.Error.Write(">>>>ERROR<<<< "+("btOpen")+": not a B-tree root "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+"\n");
            releaseEnt(ent, accnone);
            ent = null;
          }
        else ent = findEnt(ent, leaf,  -1, keyStr, kLen);
        if (!(a2b(ent)))
          ;
        else if ((accread)==(accmode))
          ;
        else if (ents_EntUpdateAccess_P(ent, accread, accmode))
          ;
        else {
          releaseEnt(ent, accread);
          ent = null;
        }
        if (a2b(ent))
          ent = chainFind(ent, accmode, keyStr, kLen, pkt);
        if (a2b(ent))
          {
            han_SetLast(han, ent_Id(ent));
          }
        else ;
        return ent;
      }
    }
    
    /*  I havent put the call to PREV:PREV-K-ENT inside here, */
    /*  as both paths need to call it - rjz */


    public static Ent chainFindPrevEnt(wb.Han han,int accmode,byte []keyStr,int kLen,int []pkt)
    {
      Ent ent = (cacheEntEnable_P
          && a2b(han_Last(han))
        ?tryGetEnt(han_Seg(han), han_Last(han), accmode)
        :null);
      if (a2b(ent)
          && leaf_P(ent_Blk(ent))
          && (blk_TopId(ent_Blk(ent)))==(han_Id(han))
          && a2b(blk_FindPos(ent_Blk(ent), keyStr, kLen, pkt))
          && ((pkt_MatchType(pkt))==(match)
                 || (pkt_MatchType(pkt))==(matchend)
                 || ((pkt_MatchType(pkt))==(pastp)
                            || (pkt_MatchType(pkt))==(qpastp))
                        && (pkt_MatchPos(pkt))>(blkDataStart)))
        {
          tceCt = (tceCt)+1;
          return ent;
        }
      else {
        if (a2b(ent))
          releaseEnt(ent, accmode);
        tceFct = (tceFct)+1;
        ent = prev_FindPrevEnt(getEnt(han_Seg(han), han_Id(han), accnone), leaf,  -1, keyStr, kLen);
        if (!(a2b(ent)))
          ;
        else if ((accmode)==(accread))
          ;
        else if (ents_EntUpdateAccess_P(ent, accread, accmode))
          ;
        else {
          releaseEnt(ent, accread);
          ent = null;
        }
        return ent;
      }
    }
    
    /* (REL-BUK! (SEG:ID seg) blk-num) */
    /* (edprintf "all ents in use!\n") */


    public static Ent getEnt(wb.Seg seg,int blkNum,int accmode)
    {
      if (0 > (blkNum))
        {
          Console.Error.Write(">>>>ERROR<<<< negative block number "+(blkNum)+"\n");
          return null;
        }
      else if ((blkNum)>=(seg_Used(seg)))
        {
          Console.Error.Write(">>>>ERROR<<<< bad block number "+(seg_Id(seg))+":"+(blkNum)+" (>= "+(seg_Used(seg))+")\n");
          return null;
        }
      else {
        Ent ent = getBukWait(seg_Id(seg), blkNum);
        Lentloop: 
        if (!(a2b(ent)))
          {
            ent = tryGetFreeEnt(seg, blkNum);
            if (a2b(ent))
              {
                ent_SetNext(ent, getBuk(seg_Id(seg), blkNum));
                setBuk(seg_Id(seg), blkNum, ent);
                ent_SetAcc(ent, accpend);
                ent_SetSeg(ent, seg);
                ent_SetId(ent, blkNum);
                ent_SetAge(ent,  -127);
                ent_SetDty(ent, null);
                ent_SetPus(ent, 0);
                ent_SetRef(ent, 1);
                relBuk(seg_Id(seg), blkNum);
                if ((accmode)==(accwrite))
                  {
                    ent_SetAcc(ent, accwrite);
                    ent_SetDty(ent, true);
                    initLeafBlk(ent_Blk(ent), blkNum, indTyp);
                    geCt = 1+(geCt);
                    return ent;
                  }
                else if (a2b(blkio_Read(seg_Port(seg), ent_Blk(ent), seg_Bsiz(seg), blkNum)))
                  {
                    ent_SetAcc(ent, accmode);
                    if ((blk_Id(ent_Blk(ent)))!=(blkNum))
                      Console.Error.Write(">>>>ERROR<<<< corrupted blk "+(seg_Id(ent_Seg(ent)))+":"+(blkNum)+" <> "+(blk_Id(ent_Blk(ent)))+"\n");
                    geCt = 1+(geCt);
                    return ent;
                  }
                else {
                  ent_SetRef(ent, 0);
                  ent_SetAcc(ent, accnone);
                  geFct = 1+(geFct);
                  return null;
                }
              }
            else {
              ent = getBukWait(seg_Id(seg), blkNum);
              goto Lentloop;
            }
          }
        else if (!((seg)==(ent_Seg(ent))
                && (blkNum)==(ent_Id(ent))))
          {
            ent = ent_Next(ent);
            goto Lentloop;
          }
        else if ((blk_Id(ent_Blk(ent)))!=(blkNum))
          {
            relBuk(seg_Id(seg), blkNum);
            Console.Error.Write(">>>>ERROR<<<< corrupted buffer "+(seg_Id(ent_Seg(ent)))+":"+(blk_Id(ent_Blk(ent)))+" <> "+(blkNum)+"\n");
            geFct = 1+(geFct);
            return null;
          }
        else if ((accnone)==(accmode))
          {
            ent_SetRef(ent, 1+(ent_Ref(ent)));
            relBuk(seg_Id(seg), blkNum);
            geCt = 1+(geCt);
            return ent;
          }
        else if ((accnone)==(ent_Acc(ent)))
          {
            ent_SetAcc(ent, accmode);
            ent_SetRef(ent, 1+(ent_Ref(ent)));
            relBuk(seg_Id(seg), blkNum);
            geCt = 1+(geCt);
            return ent;
          }
        else {
          relBuk(seg_Id(seg), blkNum);
          geFct = 1+(geFct);
          return null;
        }
      }
    }
    

    public static Ent switchEnt(Ent oldEnt,int oldacc,int newNum,int newacc)
    {
      {
        Ent newEnt = getEnt(ent_Seg(oldEnt), newNum, accnone);
        releaseEnt(oldEnt, oldacc);
        if (a2b(newEnt))
          ents_EntUpdateAccess_P(newEnt, accnone, newacc);
        return newEnt;
      }
    }
    

    public static void checkBlk(byte []blk)
    {
      {
        int bEnd = blk_End(blk);
        {
          int bPos = blkDataStart;
          Llp: 
          {
            int sPos = nextField(blk, 1+(bPos));
            if ((sPos)==(bEnd))
              
              return;
            else if ((sPos)<(bEnd))
              {
                {
                  bPos = nextCnvpair(blk, bPos);
                  goto Llp;
                }
              }
            else {
              Console.Error.Write(">>>>ERROR<<<< "+("checkBlk")+": blk "+(blk_Id(blk))+" past end "+(sPos)+"\n");
              
              return;
            }
          }
        }
      }
    }
    

    public static void checkKeyOrder(byte []blk)
    {
      byte []splitStr = new byte[0x100];
      int spos = splitKeyPos(blk);
      if (0 < (spos))
        {
          reconThisKey(blk, spos, splitStr, 0, 0x100);
          return;
        }
      else 
      return;
    }
    

    public static int doSegBuffers(wb.Seg seg,string func)
    {
      {
        int i = numBuks;
        Ent ent = null;
        Llp: 
        if (!(a2b(ent)))
          if (0==(i))
            return success;
          else {
            int T_i = (i)-1;
            ent = bukTab[(i)-1];
            i = T_i;
            goto Llp;
          }
        else if ((!(a2b(seg))
            || (seg)==(ent_Seg(ent))))
          {
            int ans = invokeFunc(func, ent);
            if (success_P(ans))
              {
                ent = ent_Next(ent);
                goto Llp;
              }
            else return ans;
          }
        else {
          ent = ent_Next(ent);
          goto Llp;
        }
      }
    }
    

    public static int checkBuffer(Ent ent)
    {
      if (!(0==(ent_Ref(ent))))
        {
          Console.Error.Write(">>>>ERROR<<<< Entry still referenced: "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+"\n");
          ent_SetRef(ent, 0);
        }
      if ((accnone)!=(ent_Acc(ent)))
        {
          Console.Error.Write(">>>>ERROR<<<< Entry still lcked: "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+"\n");
          ents_EntUpdateAccess_P(ent, ent_Acc(ent), accnone);
        }
      return success;
    }
    

    public static void checkAccess()
    {
      checkLcks();
      doSegBuffers(null, "checkBuffer");
      return;
    }
    

    /*  This routine needs to deal with lck issues. */
    /*  TBD needs to give error if lcked. */

    public static int flushBuffer(Ent ent)
    {
      if ((accnone)!=(ent_Acc(ent)))
        return terminated;
      else if (ent_Dty_P(ent))
        if (a2b(ents_EntWrite(ent)))
          return success;
        else return retryerr;
      else return success;
    }
    

    public static int purgeBuffer(Ent ent)
    {
      if (ent_Dty_P(ent))
        {
          if (((ent_Acc(ent))==(accwrite)
              || (ent_Acc(ent))==(accpend)))
            Console.Error.Write("  Purging "+(((ent_Acc(ent))==(accwrite)
        ?"ACCWRITE"
        :"ACCPEND"))+" entry: "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+"\n");
          ents_EntWrite(ent);
        }
      amnesiaEnt(ent);
      return success;
    }
    
    /* This file was generated by scm2cs from source file "scan.scm" */
    /*  "scan.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000, 2010 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */




    public static int btScan(wb.Han han,int operation,byte []kstr1,int len1,byte []kstr2,int len2,string func,int []longTab,int []respkt,int blkLimit)
    {
    LbtScan:while (true) {
      {
        int []pkt = new int[pktSize];
        int []opkt = new int[pktSize];
        Ent ent = null;
        byte []vstr = new byte[0x100];
        int accmode = ((operation)==(countScan)
          ?accread
          :accwrite);
        int result = success;
        if (keyError_P(kstr1, len1,  -2, "btScan1"))
          return keyerr;
        else if (keyError_P(kstr2, len2,  -1, "btScan2"))
          return keyerr;
        else if (hanError_P(han, "btScan"))
          return argerr;
        else if ((operation)==(modifyScan)
            && !(a2b(func)))
          {
            Console.Error.Write(">>>>ERROR<<<< "+("btScan")+": MODIFY-SCAN requires func be specified\n");
            return argerr;
          }
        else {
          ent = chainFindEnt(han, accmode, kstr1, len1, pkt);
          if (a2b(ent)
              && a2b(blk_FindPos(ent_Blk(ent), kstr2, len2, opkt)))
            {
              if ((operation)==(countScan))
                {
                  Ent nent = allocateEnt();
                  entCopy(nent, ent);
                  releaseEnt(ent, accmode);
                  result = chainScan(nent, operation, pkt, opkt, kstr1, func, longTab, vstr, respkt, han_Wcb(han));
                  recycleEnt(nent);
                }
              else {
                result = chainScan(ent, operation, pkt, opkt, kstr1, func, longTab, vstr, respkt, han_Wcb(han));
                releaseEnt(ent, accmode);
                if ((result)>0)
                  {
                    result = btPut(han, kstr1, pkt_SkeyLen(respkt), vstr, result);
                    if ((result)==(success))
                      {
                        pkt_SetSkeyCount(respkt, (pkt_SkeyCount(respkt))+1);
                        pkt_SetSkeyLen(respkt, incrementString(kstr1, pkt_SkeyLen(respkt), 0x100));
                        result = notpres;
                      }
                  }
              }
              if ((result)==(notpres)
                  && 0!=(blkLimit))
                {
                  len1 = pkt_SkeyLen(respkt);
                  blkLimit = (blkLimit)-1;
                  goto LbtScan;
                }
              else return result;
            }
          else {
            if (a2b(ent))
              releaseEnt(ent, accmode);
            remFct = 1+(remFct);
            return unkerr;
          }
        }
      }
    }
    }
    
    /*  this function increments a string lexicographically */

    public static int incrementString(byte []str,int len,int maxlen)
    {
      if ((len)<(maxlen))
        {
          str[len] = (byte) (0xff&0);
          return (len)+1;
        }
      else {
        int oldval = (str[(len)-1] & 0xFF);
        str[(len)-1] = (byte) (0xff&(1+(oldval)));
        return len;
      }
    }
    
    /*  Each call to CHAIN-SCAN scans */
    /*  all the keys within the specified range WITHIN block ENT. */
    /*  If the scan actually reaches  the end of range, it sets SKEY-LEN=0 */
    /*  and returns SUCCESS. If there's more to the range, */
    /*  it sets KEY-STR to the key to continue deleting */
    /*  from (ie, the split key of ENT), SKEY-LEN to its length, and */
    /*  returns NOTPRES (NOTDONE). The caller must then call CHAIN-FIND */
    /*  to find the START and END keys and call again. */

    public static int chainScan(Ent ent,int operation,int []pkt,int []opkt,byte []keyStr,string func,int []longTab,byte []vstr,int []respkt,int wcb)
    {
      {
        byte []blk = ent_Blk(ent);
        int result = success;
        if ((operation)==(remScan)
            && !(a2b(func))
            && (pkt_MatchPos(opkt))>(pkt_MatchPos(pkt))
            && (pkt_MatchPos(pkt))==(blkDataStart)
            && atSplitKeyPos_P(blk, pkt_MatchPos(opkt)))
          {
            {
              int keyLen = reconThisKey(blk, pkt_MatchPos(opkt), keyStr, 0, 0x100);
              subbytesMove(keyStr, 0, keyLen, blk, (blkDataStart)+2);
              setFieldLen(blk, (blkDataStart)+1, keyLen);
              blk_SetEnd(blk, (blkDataStart)+2+(keyLen));
            }
            pkt_SetSkeyCount(respkt, (pkt_SkeyCount(respkt))+1);
            remCt = 1+(remCt);
            ent_SetDty(ent, true);
            pkt_SetMatchPos(opkt, blkDataStart);
          }
        else {
          int oldct = pkt_SkeyCount(respkt);
          byte []ckstr = new byte[0x100];
          int clen = 0;
          if (a2b(func))
            clen = reconThisKey(blk, pkt_MatchPos(pkt), ckstr, 0, 0x100);
          pkt_SetMatchType(pkt, match);
          result = scanLoop(ent_Blk(ent), operation, pkt, opkt, func, longTab, respkt, ckstr, clen, vstr, seg_Bsiz(ent_Seg(ent)));
          if ((operation)!=(countScan)
              && (pkt_SkeyCount(respkt))>(oldct))
            ent_SetDty(ent, true);
        }
        if ((operation)==(remScan)
            && blkEmpty_P(blk)
            && !(endOfChain_P(blk)))
          {
            del_DeleteBck(ent);
          }
        else if (ent_Dty_P(ent))
          if (((operation)==(remScan)
                  && (0 != ((wcbSar)&(wcb))
                         || (blk_Level(blk))>(leaf))
              || (operation)==(modifyScan)
                     && 0 != ((wcbSap)&(wcb))))
            ents_EntWrite(ent);
        if ((result)!=(success))
          {
            pkt_SetSkeyLen(respkt, reconThisKey(blk, pkt_MatchPos(pkt), keyStr, 0, 0x100));
            return result;
          }
        else if ((pkt_MatchType(opkt))==(pastend)
            && !(endOfChain_P(blk)))
          {
            pkt_SetSkeyLen(respkt, reconThisKey(blk, pkt_MatchPos(pkt), keyStr, 0, 0x100));
            return notpres;
          }
        else {
          pkt_SetSkeyLen(respkt, 0);
          return success;
        }
      }
    }
    
    /*  SCAN-LOOP returns SUCCESS if it reaches the end of the range, */
    /*  else an ERROR code if terminated before that point, either */
    /*  by an error or by FUNC returning TERMINATED. */
    /*  SCAN-LOOP returns a value>0 to signal the case of */
    /*  a MODIFY that requires a block-split. That value is the */
    /*  length of the new value (which must be >0 to have caused an */
    /*  increase in block size). SCAN-LOOP NEVER returns NOTPRES. */
    /*  Note that (PKT:MATCH-POS pkt) is always the current scan point. */


    public static int scanLoop(byte []blk,int operation,int []pkt,int []opkt,string func,int []longTab,int []respkt,byte []ckstr,int clen,byte []vstr,int blksize)
    {
    LscanLoop:while (true) {
      if ((pkt_MatchPos(opkt))>(pkt_MatchPos(pkt)))
        {
          int oldBend = blk_End(blk);
          int nextPos = nextCnvpair(blk, pkt_MatchPos(pkt));
          int result = success;
          if (a2b(func))
            {
              int vpos = nextField(blk, 1+(pkt_MatchPos(pkt)));
              int vlen = fieldLen(blk, vpos);
              subbytesMove(blk, (vpos)+1, (vpos)+(vlen)+1, vstr, 0);
              result = invokeFunc(func, ckstr, clen, vstr, vlen, longTab);
            }
          if ((result)>=(success))
            {
              if ((operation)==(remScan))
                {
                  blk_RemoveKeyAndVal(blk, pkt_MatchPos(pkt), blksize);
                  pkt_SetSkeyCount(respkt, (pkt_SkeyCount(respkt))+1);
                  remCt = 1+(remCt);
                  if ((pkt_MatchPos(opkt))==(nextPos))
                    {
                      pkt_SetMatchPos(opkt, pkt_MatchPos(pkt));
                    }
                  else pkt_SetMatchPos(opkt, (pkt_MatchPos(opkt))-((oldBend)-(blk_End(blk))));
                  nextPos = pkt_MatchPos(pkt);
                }
              else if ((operation)==(countScan))
                {
                  pkt_SetSkeyCount(respkt, (pkt_SkeyCount(respkt))+1);
                  pkt_SetMatchPos(pkt, nextPos);
                }
              else if (a2b(blk_ChangeExistingValue(blk, pkt_MatchPos(pkt), ckstr, clen, vstr, result, blksize)))
                {
                  pkt_SetSkeyCount(respkt, (pkt_SkeyCount(respkt))+1);
                  nextPos = (nextPos)-((oldBend)-(blk_End(blk)));
                  pkt_SetMatchPos(opkt, (pkt_MatchPos(opkt))-((oldBend)-(blk_End(blk))));
                  pkt_SetMatchPos(pkt, nextPos);
                  result = success;
                }
              else Console.Error.Write(""+("scanLoop")+": hit modify special case\n");
            }
          else if ((result)==(notpres))
            pkt_SetMatchPos(pkt, nextPos);
          if (((result)==(success)
              || (result)==(notpres)))
            {
              if (a2b(func))
                {
                  clen = (fieldLen(blk, nextPos))+(fieldLen(blk, 1+(nextPos)));
                  subbytesMove(blk, (nextPos)+2, (nextPos)+2+(fieldLen(blk, 1+(nextPos))), ckstr, fieldLen(blk, nextPos));
                }
              goto LscanLoop;
            }
          else return result;
        }
      else return success;
    }
    }
    
    /* This file was generated by scm2cs from source file "stats.scm" */
    /*  "stats.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */



    /*  PERFORMANCE STATISTICS */


    public static int nextCt = 0;
    
    public static int nextFct = 0;
    
    public static int prevCt = 0;
    
    public static int prevFct = 0;
    
    public static int getCt = 0;
    
    public static int getFct = 0;
    
    public static int putCt = 0;
    
    public static int putFct = 0;
    
    public static int remCt = 0;
    
    public static int remFct = 0;
    
    public static int geCt = 0;
    
    public static int geFct = 0;
    
    public static int tgeCt = 0;
    
    public static int tgeFct = 0;
    
    public static int tceCt = 0;
    
    public static int tceFct = 0;
    

    public static int chainsToNext = 0;
    
    public static int deferredInserts = 0;
    
    public static int splitIndexInserts = 0;
    
    public static int indexScrewCase = 0;
    
    public static int blockSplits = 0;
    
    public static int blockDeletes = 0;
    
    public static int deferredDeletes = 0;
    
    public static int dirDtyCt = 0;
    

    public static int readCt = 0;
    
    public static int writeCt = 0;
    
    public static int readFlCt = 0;
    
    public static int writeFlCt = 0;
    
    public static int flushCt = 0;
    

    public static int clearStats()
    {
      nextCt = 0;
      nextFct = 0;
      prevCt = 0;
      prevFct = 0;
      getCt = 0;
      getFct = 0;
      putCt = 0;
      putFct = 0;
      remCt = 0;
      remFct = 0;
      geCt = 0;
      geFct = 0;
      tgeCt = 0;
      tgeFct = 0;
      tceCt = 0;
      tceFct = 0;
      chainsToNext = 0;
      deferredInserts = 0;
      splitIndexInserts = 0;
      indexScrewCase = 0;
      blockSplits = 0;
      blockDeletes = 0;
      deferredDeletes = 0;
      dirDtyCt = 0;
      readCt = 0;
      writeCt = 0;
      readFlCt = 0;
      writeFlCt = 0;
      flushCt = 0;
      return success;
    }
    

    public static int cstats()
    {
      stats();
      return clearStats();
    }
    

    public static int stats()
    {
      Console.Error.Write("\n");
      Console.Error.Write("OPERATIONS SUMMARY:\n");
      Console.Error.Write("            NEXT     PREV      GET      PUT      REM   GETENT   CACHE    CACHE\n");
      Console.Error.Write("                                                                AVAIL?   VALID?\n");
      Console.Error.Write("   succ "+(nextCt)+" "+(prevCt)+" "+(getCt)+" "+(putCt)
   +" "+(remCt)+" "+(geCt)+" "+(tgeCt)+" "+(tceCt)
   +"\n");
      Console.Error.Write("   fail "+(nextFct)+" "+(prevFct)+" "+(getFct)+" "+(putFct)
   +" "+(remFct)+" "+(geFct)+" "+(tgeFct)+" "+(tceFct)
   +"\n\n");
      Console.Error.Write("INTERNAL OPERATIONS SUMMARY:\n");
      Console.Error.Write("   chains-to-next = "+(chainsToNext)+"\n");
      Console.Error.Write("   "+(blockSplits)+" block splits, "+(deferredInserts)+" deferred parent updates, "+(deferredInserts)+" undone\n");
      Console.Error.Write("   "+(splitIndexInserts)+" split index inserts; "+(indexScrewCase)+" index-insert screw cases \n");
      Console.Error.Write("   "+(blockDeletes)+" block deletes; "+(deferredDeletes)+" deferred block deletes\n\n");
      Console.Error.Write("I/O SUMMARY: "+(readCt)+" READS, "+(writeCt)+" WRITES, "+(flushCt)+" FLUSH (of dirty bufs) calls.\n");
      Console.Error.Write("             "+(readFlCt)+" FREELIST READS, "+(writeFlCt)+" FREELIST WRITES.\n");
      Console.Error.Write("             "+(dirDtyCt)+" DIRS LEFT DTY.\n");
      {
        int ops = Math.Max((nextFct)+(prevFct)+(getFct)+(putFct)+(remFct)+(nextCt)+(prevCt)+(getCt)
         +(putCt)+(remCt), 1);
        Console.Error.Write("   AVG BLKS REFERENCED PER OPERATION: "+((0x64*((geCt)+(tceCt)))/(ops))+"%"+"\n");
        Console.Error.Write("   AVG DISK I/Os PER OPERATION: "+((0x64*((readCt)+(writeCt)+(readFlCt)+(writeFlCt)))/(ops))+"%"+"; ");
        Console.Error.Write("   WRITE/READ RATIO: "+((0x64*((writeCt)+(writeFlCt)))/(Math.Max(1, (readCt)+(readFlCt))))+"%"+"\n");
        if ((putCt)>0)
          Console.Error.Write("   AVG DISK WRITES PER PUT: "+((0x64*(writeCt))/(putCt))+"%"+"\n");
      }
      Console.Error.Write("\n");
      Console.Error.Write("MODES IN EFFECT:\n");
      Console.Error.Write(""+(numEntsCt)+" buffers [hashed over "+(numBuks)+" buckets]; blksize (max)="+(blkSize)+"; FLC-LEN="+(flcLen)
   +"\n");
      Console.Error.Write("defer-insert-updates?= "+((deferInsertUpdates_P
        ?"#t"
        :"#f"))+"; defer-block-deletes="+((del_DeferBlockDeletes_P
        ?"#t"
        :"#f"))+"\n");
      Console.Error.Write("cache-ent-enable?="+((cacheEntEnable_P
        ?"#t"
        :"#f"))+"; clever-cache-enable?="+((cleverCacheEnable_P
        ?"#t"
        :"#f"))+"\n");
      Console.Error.Write("\n");
      return success;
    }
    

    public static void showBuffer(Ent ent)
    {
      Console.Error.Write("SEG = "+(seg_Id(ent_Seg(ent)))+" ID= "+(ent_Id(ent))+" ACC= "+(ent_Acc(ent))+" REF= "+(ent_Ref(ent))
   +" DTY= "+(ent_Dty_P(ent))+" AGE= "+(ent_Age(ent))+"\n");
      return;
    }
    

    public static bool bufVerbose_P = (true);
    

    public static int showBuffer1(Ent ent)
    {
      if ((bufVerbose_P
          || (seg_Id(ent_Seg(ent)))> -1))
        {
          Console.Error.Write(" "+(seg_Id(ent_Seg(ent)))+":"+(ent_Id(ent))+" "+(hash2int(seg_Id(ent_Seg(ent)), ent_Id(ent)))+" "+(ent_Acc(ent))
   +" "+(ent_Ref(ent))+" "+0+" "+(ent_Dty_P(ent))+" "+(ent_Age(ent))
   +"");
          if ((seg_Id(ent_Seg(ent)))> -1)
            {
              Console.Error.Write(" "+((blk_Level(ent_Blk(ent)))-(leaf))+" "+(blk_Typ(ent_Blk(ent)))+"\n");
            }
          else Console.Error.Write("\n");
        }
      return success;
    }
    

    public static int showBuffers()
    {
      Console.Error.Write("\n");
      Console.Error.Write(" SEG:ID        BUK      ACC    REF READERS DTY  AGE LEVEL TYPE\n");
      return doSegBuffers(null, "showBuffer1");
    }
    

    public static int sb()
    {
      return showBuffers();
    }
    
    /* This file was generated by scm2cs from source file "db.scm" */
    /*  "db.scm" WB-tree File Based Associative String Data Base System. */
    /*  Copyright (C) 1991, 1992, 1993, 2000, 2010 Free Software Foundation, Inc. */
    /*  */
    /*  This program is free software: you can redistribute it and/or modify */
    /*  it under the terms of the GNU Lesser General Public License as */
    /*  published by the Free Software Foundation, either version 3 of the */
    /*  License, or (at your option) any later version. */
    /*  */
    /*  This program is distributed in the hope that it will be useful, but */
    /*  WITHOUT ANY WARRANTY; without even the implied warranty of */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU */
    /*  Lesser General Public License for more details. */
    /*  */
    /*  You should have received a copy of the GNU Lesser General Public */
    /*  License along with this program.  If not, see */
    /*  <http://www.gnu.org/licenses/>. */

    /*  Advertised Java and C# API */




    public static Han createBt(wb.Seg seg,int typ,int wcb)
    {
      {
        wb.Han aHan = makeHand();
        int ans = btCreate(seg, typ, aHan, wcb);
        if (err_P(ans))
          return null;
        else return aHan;
      }
    }
    

    public static Han openBt(wb.Seg seg,int blknum,int wcb)
    {
      {
        wb.Han aHan = makeHand();
        int ans = btOpen(seg, blknum, aHan, wcb);
        if (err_P(ans))
          return null;
        else return aHan;
      }
    }
    

    public static void closeBt(wb.Han han)
    {
      btClose(han);
      
    }
    

    public static Han createDb(wb.Seg seg,int typ,byte []nameStr)
    {
      byte []tmpStr = new byte[0x100];
      wb.Han aHan = createBt(seg, typ, 0);
      wb.Han dHan = openBt(seg, 1, (wcbSap)+(wcbSar));
      if ((!(a2b(aHan))
          || !(a2b(dHan))))
        return null;
      else {
        long2str(tmpStr, 1, han_Id(aHan));
        tmpStr[0] = (byte) (0xff&4);
        btPut(dHan, nameStr, nameStr.Length, tmpStr, 5);
        closeBt(dHan);
        return aHan;
      }
    }
    

    public static Han openDb(wb.Seg seg,byte []nameStr)
    {
      byte []tmpStr = new byte[0x100];
      wb.Han dHan = openBt(seg, 1, (wcbSap)+(wcbSar));
      if (!(a2b(dHan)))
        return null;
      else {
        int tlen = btGet(dHan, nameStr, nameStr.Length, tmpStr);
        closeBt(dHan);
        if (err_P(tlen))
          return null;
        else if ((tlen)==5)
          return openBt(seg, str2long(tmpStr, 1), 0);
        else return null;
      }
    }
    

    public static int flushEnts(int attempts,int k)
    {
      return entsFlush(attempts, k);
    }
    
    /*  get returns a string of the value or #f */


    public static byte []bt_Get(wb.Han han,byte []key)
    {
      {
        byte []tmpStr = new byte[0x100];
        int tlen = btGet(han, key, key.Length, tmpStr);
        if (err_P(tlen))
          return null;
        else return subbytes(tmpStr, 0, tlen);
      }
    }
    
    /*  next returns a string of the next key or #f if at end. */
    /*  (bt:next blk #f) returns the first key. */


    public static byte []bt_Next(wb.Han han,byte []key)
    {
      byte []tmpStr = new byte[0x100];
      {
        int tlen = (a2b(key)
          ?btNext(han, key, key.Length, tmpStr)
          :btNext(han, noByts, startOfChain, tmpStr));
        if (err_P(tlen))
          return null;
        else return subbytes(tmpStr, 0, tlen);
      }
    }
    
    /*  prev returns a string of the previous key or #f if at end. */
    /*  (bt:prev blk #f) returns the last key. */


    public static byte []bt_Prev(wb.Han han,byte []key)
    {
      byte []tmpStr = new byte[0x100];
      if (a2b(key)
          && 0==(key.Length))
        Console.Error.Write(">>>>ERROR<<<< "+("bt_Prev")+" of \"\".\n");
      {
        int tlen = (a2b(key)
          ?btPrev(han, key, key.Length, tmpStr)
          :btPrev(han, noByts, endOfChain, tmpStr));
        if (err_P(tlen))
          return null;
        else return subbytes(tmpStr, 0, tlen);
      }
    }
    
    /*  put adds an key value pair to the database whose root is blk */


    public static void bt_Put(wb.Han han,byte []key,byte []valStr)
    {
      btPut(han, key, key.Length, valStr, valStr.Length);
      return;
    }
    
    /*  rem! removes key and value.  returns #t if found, #f if not. */


    public static bool bt_Del(wb.Han han,byte []key)
    {
      return success_P(btRem(han, key, key.Length, null));
    }
    

    public static bool bt_Insert(wb.Han han,byte []key,byte []valStr)
    {
      return success_P(btWrite(han, key, key.Length, valStr, valStr.Length));
    }
    

    public static byte []bt_Rem(wb.Han han,byte []key)
    {
      {
        byte []tmpStr = new byte[0x100];
        int tlen = btRem(han, key, key.Length, tmpStr);
        if (err_P(tlen))
          return null;
        else return subbytes(tmpStr, 0, tlen);
      }
    }
    

    public static int bt_Delete(wb.Han han,byte []key,byte []key2)
    {
      byte []tmpstr = new byte[0x100];
      int klen = (a2b(key)
        ?key.Length
        :startOfChain);
      int klen2 = (a2b(key2)
        ?key2.Length
        :endOfChain);
      if (0 < (klen))
        subbytesMove(key, 0, klen, tmpstr, 0);
      return btRemRange(han, tmpstr, klen, key2, klen2);
    }
    
    /*  TBD, create second version of bt:scan which returns count (no blklimit). */


    public static byte []bt_Scan(wb.Han bthan,int op,byte []kstr1,byte []kstr2,string func,int blklimit)
    {
      int len1 = 0;
      int len2 = 0;
      if (a2b(kstr1))
        {
          len1 = kstr1.Length;
        }
      else {
        len1 = startOfChain;
        kstr1 = noByts;
      }
      if (a2b(kstr2)
          && 0==(len2))
        Console.Error.Write(">>>>ERROR<<<< "+("bt_Scan")+" end key is \"\".\n");
      if (a2b(kstr2))
        {
          len2 = kstr2.Length;
        }
      else {
        len2 = endOfChain;
        kstr2 = noByts;
      }
      {
        byte []key1 = new byte[0x100];
        int []respkt = new int[pktSize];
        pkt_SetSkeyCount(respkt, 0);
        pkt_SetSkeyLen(respkt, len1);
        subbytesMove(kstr1, 0, len1, key1, 0);
        {
          int res = btScan(bthan, op, key1, len1, kstr2, len2, func, null, respkt, blklimit);
          if (err_P(res))
            return null;
          else return subbytes(key1, 0, pkt_SkeyLen(respkt));
        }
      }
    }
    


    /* "SchlepRT.cs" WB-tree File Based Associative String Data Base System.
     * Copyright (C) 1991, 1992, 1993, 2000, 2003, 2007, 2009 Free Software Foundation, Inc.
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Lesser General Public License as
     * published by the Free Software Foundation, either version 3 of the
     * License, or (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this program.  If not, see
     * <http://www.gnu.org/licenses/>.
     */
    
    /* Boolean Methods*/
    public static bool a2b(bool b) {return b;}
    public static bool a2b(Object i) {return (i!= null);}
    
    public static byte[] bytes(params byte[] bArray)
    {
        return bArray;
    }
    
    public static void subbytesMove(byte[] src, int srcStart, int srcEnd, byte[] dest, int destStart)
    {
        System.Array.Copy(src, srcStart, dest, destStart, (srcEnd - srcStart));
    }
    
    public static void subbytesMoveLeft(byte[] src, int srcStart, int srcEnd, byte[] dest, int destStart)
    {
        System.Array.Copy(src, srcStart, dest, destStart, (srcEnd - srcStart));
    }
    
    public static void subbytesMoveRight(byte[] src, int srcStart, int srcEnd, byte[] dest, int destStart)
    {
        System.Array.Copy(src, srcStart, dest, destStart, (srcEnd - srcStart));
    }
    
    //Get elements from start to end in a new array.
    public static byte[] subbytes(byte[]byts, int start, int end)
    {
        byte[]subArray = new byte[end - start];
        System.Array.Copy (byts, start, subArray, 0, (end - start));
        return subArray;
    }
    
    public static byte[] stringToBytes(string str)
    {
        if(str == null) return null;
        return Encoding.UTF8.GetBytes(str);
    }
    
    public static string bytesToString(byte[] bytes)
    {
        if (bytes == null) return null;
        return Encoding.UTF8.GetString(bytes);
    }
    
    public static Object resizeArray(Object[] old, int newLength)
    {
        int upto = (old.Length < newLength) ? old.Length : newLength;
        Object[] newArray = new Object[upto];
    
        System.Array.Copy(old, newArray, upto);
        return newArray;
    }
    
    // The invokeFunc definition is generated by scm2cs.
    // It looks like this:
    //
    // public static int invokeFunc(String funcName, params Object[] args)
    //	 {
    //		 MethodInfo method = typeof(wb).GetMethod(funcName);
    //		 return (int) method.Invoke(null, args);//first parameter is null for all static methods.
    //	 }

    /*  "Blkio.cs" WB-tree File Based Associative String Data Base System.
     * Copyright (C) 1991, 1992, 1993, 2000, 2003, 2007, 2009 Free Software Foundation, Inc.
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Lesser General Public License as
     * published by the Free Software Foundation, either version 3 of the
     * License, or (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this program.  If not, see
     * <http://www.gnu.org/licenses/>.
     */
    
    // Set to true for diagnostic output for every block read and write.
    public static bool ioDiag_P = false;
    
    public static void blkio_Init()
    {
        return;
    }
    
    public static void blkio_Final()
    {
        return;
    }
    
    // Test whether the value returned by blkio_CreateFile(),
    // blkio_OpenModifyFile(), or blkio_OpenReadOnlyFile() is a valid
    // file-descriptor.
    public static bool blkio_PortOpen_P(FileStream file, bool mutable_P)
    {
        if (file == null) return false;
        return true;
    }
    
    // http://msdn.microsoft.com/en-us/library/system.io.filestream.lock.aspx
    // Prevents other processes from changing the FileStream.
    // public virtual void Lock(long position, long length)
    
    public static FileStream blkio_CreateFile(String name,int bsiz)
    {
        FileStream file = null;
        try {
    	file = new FileStream(name, FileMode.Create, FileAccess.ReadWrite);
        } catch (IOException) {}
        if (null==file) return file;
        {
    	byte []blk = new byte[bsiz];
    	blkio_Write(file, blk, bsiz, 0);
        }
        try {
    	file.Lock(0, bsiz);
        } catch (IOException) {
    	file.Close();
    	return null;
        }
        return file;
    }
    
    public static FileStream blkio_OpenModifyFile(String name,int bsiz)
    {
        FileStream file = null;
        try {	// was FileMode.OpenOrCreate
    	file = new FileStream(name, FileMode.Open,FileAccess.ReadWrite);
        } catch (IOException) {}
        if (null==file) return file;
        try {
    	file.Lock(0, file.Length);
        } catch (IOException) {
    	file.Close();
    	return null;
        }
        return file;
    }
    
    public static FileStream blkio_OpenReadOnlyFile(String name,int bsiz)
    {
        FileStream file = null;
        try {
    	file = new FileStream(name, FileMode.Open, FileAccess.Read);
        } catch (IOException) {}
        return file;
    }
    
    // http://msdn.microsoft.com/en-us/library/system.io.filestream.unlock.aspx
    // Allows access by other processes to all or part of a file that was
    // previously locked.
    // public virtual void Unlock(long position, long length)
    
    public static void blkio_FileClose(FileStream file, int bsiz, bool mutable_P)
    {
        lock (file) {
    	file.Flush();
    	if (mutable_P)
    	    try {
    		file.Unlock(0, bsiz); // was file.Length
    	    } catch (IOException) {
    		Console.Error.Write(">>>>ERROR<<<<  couldn't Unlock file.\n");
    		//Console.Error.Write(">>>>ERROR<<<<  couldn't Unlock file \""+(File.Name)+"\".\n");
    	    }
    	file.Close();
        }
        return;
    }
    
    // http://msdn.microsoft.com/en-us/library/system.io.stream.flush.aspx
    // public abstract void Flush()
    
    public static void blkio_FlushToFile(FileStream file, bool metadata_P)
    {
        lock (file) {
    	file.Flush();
        }
        return;
    }
    
    // http://msdn.microsoft.com/en-us/library/c5kehkcz%28VS.71%29.aspx
    // lock Statement
    //
    // The lock keyword marks a statement block as a critical section by
    // obtaining the mutual-exclusion lock for a given object, executing a
    // statement, and then releasing the lock. This statement takes the
    // following form:
    //
    // lock(expression) statement_block
    //
    // where:
    // expression
    //     Specifies the object that you want to lock on. expression must
    //     be a reference type.
    //
    //     Typically, expression will either be this, if you want to
    //     protect an instance variable, or typeof(class), if you want to
    //     protect a static variable (or if the critical section occurs in
    //     a static method in the given class).
    //
    // statement_block
    //     The statements of the critical section. 
    
    // http://msdn.microsoft.com/en-us/library/system.io.stream.position.aspx
    // public abstract long Position { get; set; }
    
    // http://msdn.microsoft.com/en-us/library/system.io.stream.read.aspx
    // public abstract int Read(byte[] buffer, int offset, int count)
    
    public static bool blkio_Read(FileStream file,byte []blk,int bsiz,int blknum)
    {
        long pos = bsiz*((long)blknum);
        int lrd;
        lock (file) {
    	file.Position = pos;
    	lrd = file.Read(blk, 0, bsiz);
        }
        if (bsiz==lrd) {
    	if (ioDiag_P)
    	    Console.Error.Write("rd:"+(1+blk_Level(blk)-leaf)+" "+(blk_Typ(blk))+"\n");
    	if (blk_Typ_P(blk, frlTyp)) {
    	    readFlCt = (readFlCt)+1;
    	}
    	else readCt = (readCt)+1;
    	return (true);
        }
        else {
    	Console.Error.Write(">>>>ERROR<<<<  couldn't read blk "+(blknum)+"\n");
    	return false;
        }
    }
    
    // http://msdn.microsoft.com/en-us/library/system.io.stream.write.aspx
    // public abstract void Write(byte[] buffer, int offset, int count)
    
    public static bool blkio_Write(FileStream file,byte []blk,int bsiz,int blknum)
    {
        long pos = bsiz*((long)blknum);
        try {
    	lock (file) {
    	    file.Position = pos;
    	    file.Write(blk, 0, bsiz);
    	}
    	if (ioDiag_P)
    	    Console.Error.Write("wr:"+(1+blk_Level(blk)-leaf)+" "+(blk_Typ(blk))+"\n");
    	if (blk_Typ_P(blk, frlTyp)) {
    	    writeFlCt = (writeFlCt)+1;
    	}
    	else writeCt = (writeCt)+1;
    	return true;
        } catch (IOException)
    	{
    	    Console.Error.Write(">>>>ERROR<<<<  couldn't write blk "+(blknum)+"\n");
    	    return false;
    	}
    }
    
    /*  Don't need to write block when extending. */
    
    public static bool blkio_FileExtend(FileStream file,int bsiz,int blknum)
    {
        long pos = bsiz*((long)blknum);
        try {
    	lock (file) {
    	    file.Position = pos;
    	    if (pos==file.Position) {
    		if (ioDiag_P)
    		    Console.Error.Write("Extending file to blk "+(blknum)+"\n");
    	    }
    	}
    	return true;
        } catch (IOException) {
    	Console.Error.Write(">>>>ERROR<<<<  couldn't extend file to blk "+(blknum)+"\n");
    	return false;
        }
    }

    /* "Lck.cs" WB-tree File Based Associative String Data Base System.
     * Copyright (C) 1991, 1992, 1993, 2000, 2003, 2007, 2009 Free Software Foundation, Inc.
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Lesser General Public License as
     * published by the Free Software Foundation, either version 3 of the
     * License, or (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this program.  If not, see
     * <http://www.gnu.org/licenses/>.
     */
    
    public class Lck {
        public Lck next;
        public int flg;
        public int name;
    }
    
    public static Lck lastLck;
    
    public static Lck makeLck(int name)
    {
        Lck lk = new Lck();
        lk.next = lastLck;
        Interlocked.Exchange(ref lk.flg, 0);
        lk.name = name;
        lastLck = lk;
        return lk;
    }
    
    public static bool tryLck_P(Lck lk)
    {
        if (1==Interlocked.Exchange(ref lk.flg, 1)) return false;
        return true;
    }
    
    public static void lck(Lck lk)
    {
        if (1==Interlocked.Exchange(ref lk.flg, 1))
    	Console.Error.Write(">>>>ERROR<<<< spinning on lck " + lk.name);
    }
    
    public static void unlck(Lck lk)
    {
        if (0==Interlocked.Exchange(ref lk.flg, 0))
    	Console.Error.Write(">>>>ERROR<<<< unlcking unlck "+ lk.name);
    }
    
    public static void checkLcks()
    {
        Lck lck = lastLck;
        while (lck!=null) {
    	if (lck.flg != 0) {
    	    if (lck.name < 0)
    		switch(lck.name) {
    		case -1:
    		    Console.Error.Write(">>>>ERROR<<<< free-ent-lck left lcked\n");
    		    break;
    		case -2:
    		    Console.Error.Write(">>>>ERROR<<<< flush-buk-lck left lcked\n");
    		    break;
    		default:
    		    Console.Error.Write(">>>>ERROR<<<< unknown lck left lcked\n");
    		    break;
    		}
    	    else
    		Console.Error.Write(">>>>ERROR<<<< lck " + lck.name + "  left lcked\n");
    	    Interlocked.Exchange(ref lck.flg, 0);
    	}
    	lck = lck.next;
        }
    }

    /* "Ent.cs" WB-tree File Based Associative String Data Base System.
     * Copyright (C) 1991, 1992, 1993, 2000, 2003, 2007, 2009 Free Software Foundation, Inc.
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Lesser General Public License as
     * published by the Free Software Foundation, either version 3 of the
     * License, or (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this program.  If not, see
     * <http://www.gnu.org/licenses/>.
     */
    
    public class Ent {
        public Ent NEXT;
        public int ID;
        public byte[] BLK;
        public bool DTY;
        public int TAG, AGE, PUS, ACC, REF;
        public Seg SEG;
    }
    
    public static Ent makeEntry()
    {
        return new Ent();
    }
    
    public static Ent ent_MakeEnt(int tag)
    {
        //System.out.println("blkSize = " + blkSize);
        Ent ent = new Ent();
        ent.TAG = tag;
        //ent.SEG = null;
        ent.ID  = -1;
        ent.BLK = new byte[blkSize];
        return ent;
    }
    
    //The getter methods in C take struct entry as a parameter.
    // Here we use object methods, thus the function ent_tag(ent)
    //in C appears as ent.entTag() in Java.
    public static int ent_Tag(Ent entry)
    {
        return entry.TAG;
    }
    
    public  static Ent  ent_Next(Ent entry)
    {
        return entry.NEXT;
    }
    
    public static Seg ent_Seg(Ent entry)
    {
        return entry.SEG;
    }
    
    public static int ent_Id(Ent entry)
    {
        return entry.ID;
    }
    
    public static byte[] ent_Blk(Ent entry)
    {
        return entry.BLK;
    }
    
    public static int ent_Age(Ent entry)
    {
        return entry.AGE;
    }
    
    public static bool  ent_Dty_P(Ent entry)
    {
        return entry.DTY;
    }
    
    public static int ent_Pus(Ent entry)
    {
        return entry.PUS;
    }
    
    public static int ent_Acc(Ent entry)
    {
        return entry.ACC;
    }
    
    public static int ent_Ref(Ent entry)
    {
        return entry.REF;
    }
    //As with getter methods, we do not take  ry object as parameter,
    //but invoke methods on the objects.
    
    public static void ent_SetTag(Ent entry, int tag)
    {
        entry.TAG = tag;
    }
    
    public static void ent_SetNext(Ent entry, Ent next)
    {
        entry.NEXT = next;
    }
    
    public static void ent_SetSeg(Ent entry, Seg seg)
    {
        entry.SEG = seg;
    }
    
    public static void ent_SetId(Ent entry, int num)
    {
        entry.ID = num;
    }
    
    public static void ent_SetAge(Ent entry, int age)
    {
        entry.AGE = age;
    }
    
    public static void ent_SetDty(Ent entry, Object A) //for handling nulls.
    {
        entry.DTY = ((A==null)? false:true);
    }
    
    public static void ent_SetDty(Ent entry, bool dty)
    {
        entry.DTY = dty;
    }
    
    public static void ent_SetPus(Ent entry, int pus)
    {
        entry.PUS = pus;
    }
    
    public static void ent_SetAcc(Ent entry, int acc)
    {
        entry.ACC = acc;
    }
    
    public static void ent_SetRef(Ent entry, int Ref)
    {
        entry.REF = Ref;
    }

    /* "Han.cs" WB-tree File Based Associative String Data Base System.
     * Copyright (C) 1991, 1992, 1993, 2000, 2003, 2007, 2009 Free Software Foundation, Inc.
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Lesser General Public License as
     * published by the Free Software Foundation, either version 3 of the
     * License, or (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this program.  If not, see
     * <http://www.gnu.org/licenses/>.
     */
    
    public class Han {
        public Seg SEG;
        public int TYP;
        public int ID, LAST;
        public int WCB, SPARE;
    }
    
    public static Han makeHand()
    {
        return new Han();
    }
    
    //The getter & setter methods follow the same syntax translations as
    //the corresponding methods in Entry.
    public static int han_Id(Han han)
    {
        return han.ID;
    }
    
    public static Seg han_Seg(Han han)
    {
        return han.SEG;
    }
    
    public static int han_Typ(Han han)
    {
        return han.TYP;
    }
    
    public static int han_Last(Han han)
    {
        return han.LAST;
    }
    
    public static int han_Wcb(Han han)
    {
        return han.WCB;
    }
    
    //setter
    public static void han_SetNum(Han han, int num)
    {
        han.ID = num;
    }
    
    public static void han_SetSeg(Han han, Seg seg)
    {
        han.SEG = seg;
    }
    
    public static void han_SetTyp(Han han, int typ)
    {
        han.TYP = typ;
    }
    
    public static void han_SetLast(Han han, int last)
    {
        han.LAST = last;
    }
    
    public static void han_SetWcb(Han han, int wcb)
    {
        han.WCB = wcb;
    }

    /* "Seg.cs" WB-tree File Based Associative String Data Base System. */
    
    public class Seg {
        public FileStream PORT;
        public int BSIZ;
        public int USED;
        public String STRN;
        public Han RT_HAN, FL_HAN;
        public Lck FLCK;
        public Lck FFCK;
        public int FLC_LEN;
        public int []FLC;
        public Seg PRV, NXT;
        public int ID;
    }
    
    /*  The SEG (segment) methods*/
    public static Seg newSegd(int idx)
    {
        Seg seg = new Seg();
        seg.RT_HAN = makeHand();
        seg.FL_HAN = makeHand();
        seg.FLCK = makeLck( 0-idx);
        seg.FFCK = makeLck(-1-idx);
        seg.ID = idx;
        return seg;
    }
    
    public static FileStream seg_Port(Seg seg)
    {
        return seg.PORT;
    }
    
    public static int seg_Bsiz(Seg seg)
    {
        return seg.BSIZ;
    }
    
    public static int seg_Used(Seg seg)
    {
        return seg.USED;
    }
    
    public static String seg_Str(Seg seg)
    {
        return seg.STRN;
    }
    
    public static Han seg_RtHan(Seg seg)
    {
        return seg.RT_HAN;
    }
    
    public static Han seg_FlHan(Seg seg)
    {
        return seg.FL_HAN;
    }
    
    public static Lck seg_Lck(Seg seg)
    {
        return seg.FLCK;
    }
    
    public static Lck seg_Fck(Seg seg)
    {
        return seg.FFCK;
    }
    
    public static int seg_FlcLen(Seg seg)
    {
        return seg.FLC_LEN;
    }
    
    public static int[] seg_Flc(Seg seg)
    {
        return seg.FLC;
    }
    
    public static int seg_Id(Seg seg)
    {
        if (null==seg) return -1;
        else return seg.ID;
    }
    
    public static bool seg_Mutable_P(Seg seg)
    {
        return seg.FLC_LEN != -2;
    }
    
    public static Seg seg_Prv(Seg seg)
    {
        return seg.PRV;
    }
    
    public static Seg seg_Nxt(Seg seg)
    {
        return seg.NXT;
    }
    
    public static void seg_SetPort(Seg seg,FileStream port)
    {
        seg.PORT = port;
    }
    
    public static void seg_SetBsiz(Seg seg,int bsiz)
    {
        seg.BSIZ = bsiz;
    }
    
    public static void seg_SetUsed(Seg seg,int used)
    {
        seg.USED = used;
    }
    
    public static void seg_SetStr(Seg seg,String str)
    {
        seg.STRN = str;
    }
    
    public static void seg_SetFlcLen(Seg seg,int flcLen)
    {
        seg.FLC_LEN = flcLen;
    }
    
    public static void seg_SetFlc(Seg seg,int[] flc)
    {
        seg.FLC = flc;
    }
    
    public static void seg_SetPrv(Seg seg, Seg prv)
    {
        seg.PRV = prv;
    }
    
    public static void seg_SetNxt(Seg seg, Seg nxt)
    {
        seg.NXT = nxt;
    }

    /* "Pkt.cs" WB-tree File Based Associative String Data Base System. */
    
    /*  Routines for finding the appropriate BLK for an operation. */
    /*  PACKETs used to return multiple values from chain-find. */
    /*  and various other operations */
    
    public static readonly int pktSize = 6;
    
    public static int[] makePkt()
    {
        return new int[pktSize];
    }
    
    public static int pkt_MatchType(int[] p)
    {
        return p[0];
    }
    
    public static int pkt_MatchPos(int[] p)
    {
        return p[1];
    }
    
    public static int pkt_KeyPos(int[] p)
    {
        return p[2];
    }
    
    public static int pkt_PrevMatchPos(int[] p)
    {
        return p[3];
    }
    
    public static int pkt_BlkToCache(int[] p)
    {
        return p[4];
    }
    
    public static int pkt_SuccessCode(int[] p)
    {
        return p[5];
    }
    
    public static void pkt_SetMatchType(int[] p,int v)
    {
        p[0] = v;
    }
    
    public static void pkt_SetMatchPos(int[] p,int v)
    {
        p[1] = v;
    }
    
    public static void pkt_SetKeyPos(int[] p,int v)
    {
        p[2] = v;
    }
    
    public static void pkt_SetPrevMatchPos(int[] p,int v)
    {
        p[3] = v;
    }
    
    public static void pkt_SetBlkToCache(int[] p,int v)
    {
        p[4] = v;
    }
    
    public static void pkt_SetSuccessCode(int[] p,int v)
    {
        p[5] = v;
    }
    
    //Aliases
    public static int pkt_SkeyCount(int[] p)
    {
        return pkt_MatchPos(p);
    }
    
    public static void pkt_SetSkeyCount(int[] p, int v)
    {
        pkt_SetMatchPos(p, v);
    }
    
    public static int pkt_SkeyLen (int[] p)
    {
        return pkt_KeyPos(p);
    }
    
    public static void pkt_SetSkeyLen (int[]p, int v)
    {
        pkt_SetKeyPos(p, v);
    }
    
    public static void pkt_Pack(int[] p,int type,int bPos,int kPos,int pPos)
    {
        pkt_SetMatchType(p, type);
        pkt_SetMatchPos(p, bPos);
        pkt_SetKeyPos(p, kPos);
        pkt_SetPrevMatchPos(p, pPos);
    }

    /* "Blk.cs" WB-tree File Based Associative String Data Base System.
     * Copyright (C) 1991, 1992, 1993, 2000, 2003, 2007, 2009 Free Software Foundation, Inc.
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Lesser General Public License as
     * published by the Free Software Foundation, either version 3 of the
     * License, or (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this program.  If not, see
     * <http://www.gnu.org/licenses/>.
     */
    
    /*  BLK parameters */
    /*  The IDs are 4 byte numbers identifying this block, the root of */
    /*  this tree, and the next in the chain. */
    public static readonly int blkIdPos = 0;
    
    public static readonly int blkTopIdPos = 4;
    
    public static readonly int blkNxtIdPos = 8;
    
    public static readonly int blkTimePos = 0xc;
    /*  blk-end-pos is position (stored in 2 bytes) of first free byte */
    
    public static readonly int blkEndPos = 0x10;
    
    public static readonly int blkLevelPos = 0x12;
    
    public static readonly int blkTypPos = 0x13;
    
    public static readonly int blkDataStart = 0x14;
    
    public static int blk_Id(byte[] blk)
    {
        return str2long(blk, blkIdPos);
    }
    
    public static int blk_TopId(byte[] blk)
    {
        return str2long(blk, blkTopIdPos);
    }
    
    public static int blk_NxtId(byte[] blk)
    {
        return str2long(blk, blkNxtIdPos);
    }
    
    public static int blk_Time(byte[] blk)
    {
        return str2long(blk, blkTimePos);
    }
    
    public static int blk_End(byte[] blk)
    {
        return str2short(blk, blkEndPos);
    }
    
    public static int blk_Level(byte[] b)
    {
        return (b[blkLevelPos]);
    }
    
    public static int blk_Typ(byte[] b)
    {
        return (b[blkTypPos]);
    }
    
    public static bool  blk_Typ_P(byte[] b,int typ)
    {
        return ((b[blkTypPos]))==(typ);
    }
    
    public static void blk_SetId(byte[] blk,int id)
    {
        long2str(blk, blkIdPos, id);
    }
    
    public static void blk_SetTopId(byte[] blk,int id)
    {
        long2str(blk, blkTopIdPos, id);
    }
    
    public static void blk_SetNxtId(byte[] blk,int id)
    {
        long2str(blk, blkNxtIdPos, id);
    }
    
    public static void blk_SetTime(byte[] blk,int time)
    {
        long2str(blk, blkTimePos, time);
    }
    
    public static void blk_SetEnd(byte[] blk,int pos)
    {
        short2str(blk, blkEndPos, pos);
    }
    
    public static void blk_SetLevel(byte[] b,int level)
    {
        //b[blkTypPos] = -128 + typ;
    	b[blkLevelPos] = (byte) (0xFF & level);
    }
    
    public static void blk_SetTyp(byte[] b,int typ)
    {
        //b[blkTypPos] = -128+typ;
    	b[blkTypPos] = (byte) (0xFF & typ);
    }

    
    /* Wrapper functions for db access that take strings instead
       of byte arrays */
    // public static int bt_Del(Han han, String keyStr)
    // {
    //     return bt_Del(han, stringToBytes(keyStr));
    // }
    
    public static Han createDb(Seg seg, int typ, String nameStr)
    {
        return createDb(seg, typ, stringToBytes(nameStr));
    }
    
    public static Han createDb(Seg seg, char typ, String nameStr)
    {
        return createDb(seg, (int)typ, stringToBytes(nameStr));
    }
    
    public static Han openDb(Seg seg, String nameStr)
    {
        return openDb(seg, stringToBytes(nameStr));
    }
    
    public static void bt_Delete(Han han, String keyStr, String key2Str)
    {
        bt_Delete(han, stringToBytes(keyStr), stringToBytes(key2Str));
    }
    
    public static String bt_Get(Han han, String keyStr)
    {
        byte[] byts = bt_Get(han, stringToBytes(keyStr));
        return bytesToString(byts);
    }
    
    public static String bt_Next(Han han, String keyStr)
    {
        byte[] byts = bt_Next(han, stringToBytes(keyStr));
        return bytesToString(byts);
    }
    
    
    public static String bt_Prev(Han han, String keyStr)
    {
        byte[] byts = bt_Prev(han, stringToBytes(keyStr));
        return bytesToString(byts);
    }
    
    public static void bt_Put(Han han, String keyStr, String key2Str)
    {
        bt_Put(han, stringToBytes(keyStr), stringToBytes(key2Str));
    }
    
    public static String bt_Rem(Han han, String keyStr)
    {
        byte[] byts = bt_Rem(han, stringToBytes(keyStr));
        return bytesToString(byts);
    }
  }
}
